# 前端-面试知识总结

简介：本文为前端面试相关知识点总结，完整笔记详见[Github](https://github.com/MrEnvision/Front-end_learning_notes)

作者：[Envision](https://github.com/MrEnvision)          联系邮箱：[EnvisionShen@gmail.com](mailto:EnvisionShen@gmail.com)



# 一、算法相关

## 1、全排列

```js
function permutate(str) {
    let ans = [];
    let newStr = str.split('');
    let length = newStr.length;
    newStr.sort();
    const swap = function (arr, i, j) {
        let temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
    }
    const perm = function (array, depth) {
        if (depth === length) {
            ans.push(array.join())
        } else {
            perm(array, depth + 1)
            for (let i = depth + 1; i < array.length; i++) {
                if (array[i] !== array[depth]) { // 去重
                    let newArr = [...array]
                    swap(newArr, depth, i)
                    perm(newArr, depth + 1)
                }

            }
        }
    }
    perm(newStr, 0)
    return ans
}
```

## 2、折半查找

```js
// 递归法
function binarySearch(array, target) {
    const search = function (low, high) {
        if (low > high) {
            return null
        }
        let mid = Math.floor((low + high) / 2)
        if (array[mid] === target) {
            return mid
        } else if (array[mid] > target) {
            high = mid - 1
            return search(low, high)
        } else {
            low = mid + 1
            return search(low, high)
        }
    }
    return search(0, array.length - 1)
}

// 非递归法
function binarySearch2(array, target) {
    let low = 0;
    let high = array.length - 1;
    while (low <= high) {
        let mid = Math.floor((low + high) / 2)
        if (array[mid] === target) {
            return mid
        } else if (array[mid] < target) {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return null
}
```

## 3、排序算法

### 3.1、直接插入排序

```js
function insertSort(array) {
    for (let i = 1; i < array.length; i++) {
        const temp = array[i]
        let j;
        for (j = i - 1; j >= 0 && temp < array[j]; j--) {
            array[j+1] = array[j]
        }
        array[j+1] = temp
    }
    return array
}
```

### 3.2、折半插入排序

```js
function insertSort(array) {
    for (let i = 1; i < array.length; i++) {
        let temp = array[i];
        // 折半查找获取temp的index
        // ...略
        // 调整位置
        let k;
        for (k = i; k > index; k--) {
            array[k] = array[k - 1]
        }
        array[k] = temp
    }
    return array
}
```

### 3.3、冒泡排序

```js
function bubbleSort(array) {
    for (let i = 0; i < array.length; i++) {
        let flag = false; // 如果一趟排序未发生改变则排序完成
        for (let j = 1; j < array.length - i; j++) {
            if (array[j] < array[j - 1]) {
                let temp = array[i]
                array[i] = array[j]
                array[j] = temp
                flag = true;
            }
        }
        if (!flag) break;
    }
    return array
}
```

### 3.4、快速排序

```js
function quickSort(array) {
    const partition = function (array, low, high) {
        let pivot = array[low]
        while (low < high) {
            while (low < high && array[high] > pivot) {
                high--
            }
            array[low] = array[high]
            while (low < high && array[low] <= pivot) {
                low++
            }
            array[high] = array[low]
        }
        array[low] = pivot
        return low
    }
    const sort = function (array, low, high) {
        if (low < high) {
            let index = partition(array,low,high)
            sort(array,low,index-1)
            sort(array,index+1,high)
        }
    }
    sort(array, 0, array.length - 1)
    return array
}
```

### 3.5、选择排序

```js
function selectSort(array) {
    for (let i = 0; i < array.length; i++) {
        let index = i;
        for (let j = i + 1; j < array.length; j++) {
            if (array[index] > array[j]) {
                index = j
            }
        }
        // 交换index和i
        let temp = array[index]
        array[index] = array[i]
        array[i] = temp
    }
    return array
}
```

### 3.6、归并排序

```js
function sort(array) {
    const merge = function (array1, array2) {
        let res = [];
        let i, j;
        for (i = 0, j = 0; i < array1.length && j < array2.length;) {
            if (array1[i] < array2[j]) {
                res.push(array1[i]);
                i++;
            } else {
                res.push(array2[j]);
                j++;
            }
        }
        if (i < array1.length) res = res.concat(array1.slice(i))
        if (j < array2.length) res = res.concat(array2.slice(j))
        return res
    }
    const mergeSort = function (array, low, high) {
        if (low === high) {
            return [array[low]]
        } else {
            let mid = Math.floor((high + low) / 2)
            let array1 = mergeSort(array, low, mid)
            let array2 = mergeSort(array, mid + 1, high)
            return merge(array1, array2)
        }
    }
    return mergeSort(array, 0, array.length - 1)
}
```

### 3.7、希尔排序

```js
function shellSort(array) {
    let gap = Math.floor(array.length / 2)
    while (gap) {
        for (let i = gap; i < array.length; i++) {
            const temp = array[i]
            let j;
            for (j = i - gap; j >= 0 && temp < array[j]; j = j - gap) {
                array[j + gap] = array[j]
            }
            array[j + gap] = temp
        }
        gap = Math.floor(gap / 2)
    }
    return array
}
```

## 4、位运算的作用

暂无。



# 二、Javascript知识

## 1、原型链、继承

常见问题：

> 1、原型链图

<img src='img/原型链.png' />

关键点：

1. `__proto__`和`constructor`属性是对象所独有的；② `prototype`属性是函数所独有的，函数也是对象，因此拥有3个属性。
2. `__proto__`指向父对象，`constructor`指向构造函数， `prototype`构造函数指向其原型。
3. `__proto__`最终都会到达`Object.prototype`至null，`constructor`最终都会达到`Function()`，构造函数的`__proto__`都指向`Function.prototype`.

> 2、ES5原型链继承(多种) + ES6继承

|              | 原理                             | 父类实例属性继承 | 父类原型属性继承 | 多继承 |
| ------------ | -------------------------------- | ---------------- | ---------------- | ------ |
| 原型链继承   | 子类的原型是父类的实例           | +                | +                | -      |
| 构造继承     | 子类调用父类构造函数             | +                | -                | +      |
| 实例继承     | 父类实例作为子类实例返回         | +                | +                | -      |
| 拷贝继承     | 子类原型拷贝父类实例的属性和方法 | +                | +                | +      |
| 组合继承     | 调用父类构造，子类原型是父类实例 | +                | +                | ？     |
| 寄生组合继承 | /                                | +                | +                | ？     |

注意：ES6的继承super实际执行的是父类.prototype.constructor.call(this)

## 2、数据类型

常见问题：

> 1、基本数据类型（6种）+引用对象类型（8种）

- 基本数据类型 - null, undefined, number, boolean, string, symbol
- 引用对象类型 - Object, Function, Array, Date, RegExp, String, Boolean, Number

> 2、类型转换

- 隐式类型转换：一般遵循Object->String->Number和Boolean->Number
- 强制类型转换：target.toString(), Number(target)/parseInt(target)/parseFloat(target), Boolean(target)

> 3、类型判断

- `typeof 目标 === 'object'` - 可以判断基本数据类型(除null为object)，引用对象类型均为object(除function)
- `目标 instanceof Array === true` - 不可以判断基本数据类型，可以判断引用对象类型包括自定义对象
- `Object.prototype.toString.call(目标).slice(8,-1).toLowerCase() === 'string' ` - 可以判断基本数据类型和引用对象类型，不能识别自定义对象
- `目标.constructor === Object` - 可以判断基本数据类型(除null和undefined)和对象数据类型(内置和自定义)

> 4、instanceof的原理？

- 判断一个对象与构造函数是否在一个原型链上

```js
function instance_of(L, R) {
    var O = R.prototype; 
    L = L.__proto__;
    while (true) {    
        if (L === null)      
             return false;   
        if (O === L) 
             return true;   
        L = L.__proto__;  
    }
}
```

> 5、赋值、深拷贝与浅拷贝 / 浅拷贝方法 / 深拷贝方法

- 赋值——基本类型传值，引用类型传引用地址
- 浅拷贝——只赋值非对象属性，对象属性是传引用地址，会互相影响
  - Object.assign(target, source)
  - 扩展运算符`...`
- 深拷贝——完全一致的对象，切不影响原始对象
  - target=JSON.parse(JSON.stringify(source)); —— 弊端
  - 自定义拷贝（包装对象data、number、string和boolean、RegExp需要使用valueof()转成原始值）

> 6、自定义对象深拷贝？

```js
const deepCopy = function (obj) {
    if (typeof obj !== 'object') return obj;
    let newObj = obj instanceof Array ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];
        }
    }
    return newObj
}
```

> 7、==、===、Object.is区别？

- ==值相等，===和Object.is值和类型相等，但NaN，+0/-0有区别，Object.is(NaN,NaN)为true，Object.is(+0,-0)为false。

> 8、map、set、array的区别？

|      | Array                          | Set          | Map  |
| ---- | ------------------------------ | ------------ | ---- |
| 初始化 | new Array(value, value) / [] | set.size     | new Map([[key,value],[key,value]]) |
| 长度 | array.length                   | set.size     | map.size |
| 增   | array.push() / array.unshift() | set.add()    | map.set(key, value) |
| 删   | array.pop() / array.shift()    | set.delete() | map.delete(key) |
| 查 | array.length                   | set.has()    | map.get(key) / map.has(key) |

**遍历**：map/set/array - values()/keys()/entries()  或者  forEach((value,key)=>{}) （数组其他方法还有很多）

⚠️ entries()参数是先key后value，forEach参数是先value后key。

⚠️ entries()两个参数用数组包裹，`for(let [key,value] of array.entries()){}`。

⚠️Set遍历的key和value为相等！！！区别于array的key为索引

## 3、this指向

常见问题：

> 1、this 指向有哪几种？

- 默认绑定：全局环境中，this默认绑定到window。
- 隐式绑定：一般被直接对象所包含的函数调用时，this隐式绑定到该直接对象。
- 隐式丢失：call()、apply()、bind()方法。
- new绑定：一般绑定至new生成的新对象，但是如果构造函数返回一个对象，则绑定至该对象。

<img src='img/this.png'>

> 2、改变函数内部 this 指针的指向函数？

|       | 调用方式     | 第一个参数           | 其余参数       |
| ----- | ------------ | -------------------- | -------------- |
| bind  | 返回一个函数 | this指向改变后的对象 | 直接传递       |
| apply | 函数直接调用 | this指向改变后的对象 | 用数组包裹参数 |
| call  | 函数直接调用 | this指向改变后的对象 | 直接传递       |

注意：如果第一个参数为null或undefined，this的指向就是全局变量，在浏览器里就是window对象。

> 3、bind多次绑定后的this指向？

- 不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定。

```js
let a = {"x": 10}
let b = {"x": 5}
let fn = function () {
    console.log(this.x)
}
fn.bind(b).bind(a)() // 5
fn.bind(a).bind(b)() // 10
```

> 4、自定义bind函数？

```js
Function.prototype.newBind = function () {
    const func = this
    const context = Array.from(arguments)[0]
    let args = Array.from(arguments).slice(1)
    const returnFunc = function () {
        args = args.concat(Array.from(arguments))
        return func.apply(this instanceof func ? this : context, args)
    }
    const newFunction = function () {
    }
    newFunction.prototype = func.prototype;
    returnFunc.prototype = new newFunction();
    return returnFunc()
}
```

## 4、函数

常见问题：

> 1、箭头函数与普通函数的区别？

- 箭头函数没有this，需要去上下文环境中找(也就是说在定义的时候就确定了)
- 箭头函数没有arguments，但可以借助...resets剩余运算符实现
- 箭头函数不能用作构造函数

> 2、构造函数new的过程？

```js
const Func=function(){ };  
const func=new Func (); 
// 原理
const obj=new Object();  
obj.__proto__= Func.prototype;   
const result =Func.call(obj); 
if (typeof(result) == "object"){  
  func=result;  
}else{  
  func=obj;;  
}
```

> 3、闭包的定义和作用？

- 闭包就是能够读取其他函数内部变量的函数，闭包是将函数内部和函数外部连接起来的桥梁。
- 作用：读取函数内部的变量；保存变量始终在内存中；

## 5、异步解决方案

常见问题：

> 1、谈谈Promise对象，Generator函数，async/await？

略。

> 2、实现sleep函数？

```js
// Promise
const sleep = time =>{
    new Promise((resolve) => {
        setTimeout(resolve, time)
    })
}

sleep(1000).then(() => {
    console.log(1)
})

// Generator
function *sleep(time) {
    yield new Promise(resolve => {
        setTimeout(resolve, time)
    })
}
sleep(1000).next().value.then(() => {
    console.log(1)
})

// async/await
async function sleep(time, func) {
    await new Promise(resolve => setTimeout(resolve, time))
    return func()
}
sleep(1000, () => {
    console.log(1)
})

// ES5
function sleep(callback,time) {
  if(typeof callback === 'function')
    setTimeout(callback,time)
}

function output(){
  console.log(1);
}
sleep(output,1000);
```

## 6、事件

常见问题：

> 1、事件代理（事件委托）？

- 概念：不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。
- 好处：动态绑定（以动态生成li为例）

> 2、DOM2级事件流？

- 事件捕获阶段、处于目标阶段、事件冒泡阶段

> 3、阻止冒泡事件 / 阻止默认事件？

- e.stopPropagation() 和 e.preventDefault()

> 4、事件监听函数的参数？

- element.addEventListener(event, function, useCapture) - useCapture默认false在冒泡阶段触发

## 7、跨域

常见问题：

> 1、跨域有哪些方法？

- CORS（Access-Control-Allow-Origin）
- JSONP
- postMessage + onmessage
- Nginx
- nodejs中间件
- WebSocket
- document.domain + iframe跨域
- location.hash + iframe跨域（onhashchange）
- window.name + iframe跨域

## 8、Ajax

常见问题：

> 1、自己实现一个原生的ajax？

```js
const xhr = new XMLHttpRequest()
// 必须在调用 open()之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    if (xhr.status >= 200 && xhr.status < 300 || xhr.status ==== 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Error:' + xhr.status)
    }
  }
}
xhr.open('get', '/api/getSth', true) // 第三个参数表示异步发送请求
xhr.send(null) // 参数为作为请求主体发送的数据
```

> 2、使用promise封装一个ajax

```js
const ajax = (url, method, async, data) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          resolve(JSON.parse(xhr.responseText))
        } else if (xhr.status > 400) {
          reject('发生错误')
        }
      }
    }
    xhr.open(url, method, async)
    xhr.send(data || null)
  })
}
```

## 9、垃圾回收

- 标记清除 + 引用计数（存在什么问题？） —— 详见[参考资料](https://segmentfault.com/a/1190000018605776?utm_source=tag-newest)

## 10、对象属性

常见问题：

> 1、获取JS对象属性的方法 ？- 3种区别

- for...in + hasOwnPropery —— 原型链 + 可枚举
- Object.keys() —— 自身+可枚举
- Object.getOwnProperyNames() —— 自身+不可枚举

> 2、监听对象属性的改变的方法？-2中方法

- ES5中使用Object.defineProperty() - 针对单个属性，无法监听属性的添加删除、数组索引和长度变更等

```js
Object.defineProperty(user,'name',{
  set：function(key,value){
  }
})
```

- ES6中使用proxy对象 - 针对整个对象

```js
const user = new Proxy({}, {
  set：function(target,key,value,receiver){
  }
})
```

## 11、数组和字符串方法

- 两者共同方法：slice,indexOf, includes, concat
- string——**slice**, **substring**, substr, **indexOf**, **replace**, **split**, **includes**, search, repeat, trim, charCodeAt
- array —— 以下插入删除操作会更改原始数组，其他都是生生新数组
  - 插入删除操作：pop, push, unshift, shift, , **splice**
  - 查询：find, findIndex, **includes**, **indexOf**, lastIndexOf（区别indexOf与findIndex）
  - 检查：every, some, filter
  - 遍历：**forEach**, map,  **reduce**
  - 其他：toString, **sort**,  **slice**, **join**, concat, fill

## 12、节流和防抖

- 节流 - 在 n 秒内只会执行一次

```js
function throttle(func, delayTime) {
    let flag;
    return function () {
        let context = this, args = arguments;
        if (!flag) {
            flag = true
            setTimeout(function () {
                func.apply(context, args);
                flag = false
            }, delayTime)
        }
    }
}
```

- 防抖 - 按最后一次算

```js
function debounce(func, delayTime) {
    let timeId;
    return function () {
        let context = this, args = arguments;
        timeId && clearTimeout(timeId);
        timeId = setTimeout(function () {
            func.apply(context, args);
        }, delayTime)
    }
}
```

## 13、模块化

常见问题：

> 1、JS模块化的方式？
>
> 2、module.exports与exports，export与export default之间的关系和区别？

- ES6模块：模块输出exports {A}，模块加载import {A} from 'path'
  - 注意：如果使用export default function() {}输出，模块加载为import anyName from 'path'。
- Commonjs：模块输出modules.exports，模块加载require()
  - 注意：`var exports = module.exports;`不建议在exports上操作，具体看情况。
- AMD/CMD

## 14、事件循环机制

常见问题：

> 1、事件循环机制规则？

- JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，每次宏任务执行完毕，先去微任务队列查找是否有微任务，如果有就先完成所有的微任务，如果没有微任务或完成所有微任务则从宏任务队列中继续执行宏任务。

> 2、哪些是宏任务和微任务？

- MacroTask(宏任务)：script(整体代码), **setTimeout, setInterval**, requestAnimationFrame, I/O
- MicroTask(微任务)：**Promise**, **await之后的代码**, process.nextTick, Object.observe, MutationObserver

注意，async中如果非异步函数，则认为顺序执行，只有await中为异步，后面的代码才进入微任务队列

## 15、setTimeout和setInterval

常见问题：

> 1、通过setTimeout来实现setInterval？

```js
const newSetInterval = function (func, time) {
    const newFunc = function(){
        func();
        setTimeout(newFunc,time)
    }
    setTimeout(newFunc, time)
}
```

## 16、正则表达式

<img src='img/RegExp.png'>

## 17、其他

常见问题：

> 1、ES6与语法的兼容性怎么解决？

- 官方推荐使用 `babel-polyfill` 来解决，在webpack配置文件(webpack.config.js)entry项中配置。

> 2、let/const/var区别 / ES5中怎么实现块级作用域

- 块级作用域，变量提升等；立即执行函数；

> 3、函数作用域链什么时候决定？

- 一般定义的时候就决定了，区别this的指向。

> 4、剩余参数...args与arguments的区别？

- 剩余运算符的args是数组，arguments是伪数组
- 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参



# 三、CSS知识

## 1、Position

- 默认static
- 绝对定位absolute - 相对于前一个非static定位的父元素，脱离文档流
- 相对定位relative - 相对于自身原来位置，未脱离文档流
- 固定定位fixed - 相对于可视窗口而言
- 粘性定位sticky - 应用于表头锁定、导航栏固定、图片堆叠等

## 2、CSS选择器

常见问题

> 1、常见CSS选择器有哪些？

- （ !important > 内联 >）ID选择器>类选择器=伪类选择器=属性选择器>标签选择器=伪元素选择器

> 2、哪些属性可以继承？

- 可以继承 - font-size, font-family, color
- 不能继承 - border, padding, margin, width, height

## 3、inline-block、inline和block

常见问题：

> 1、inline-block、inline和block的区别？

- 块元素 - display：block（常见：div、p、nav、aside、header、footer、section、article、ul-li等）
  - 独占一行，自动填满父元素
  - 设置宽高/margin/padding均有效
  - 自动换行
  - 默认排列方式为从上到下
- 行元素 - display：inline （常见：span、a）
  - 不独占一行
  - 设置宽高无效，宽仅与内容有关，但高可以通过line-height设置；设置margin上下无效，左右有效；设置padding上下无效，左右有效，但上下可以有视觉效果，比如border会被撑开。
  - 不自动换行
  - 默认排列方式为从左到右

- 行内块元素 - display：inline-block
  - 设置宽高/margin/padding均有效
  - 自动换行
  - 默认排列方式为从左到右

> 2、inline-block换行问题怎么解决？

场景描述：一个父元素宽度为1000px，三个inline-block子元素宽度为300px,300px,400px，按照正常是能在父元素中一行显示，但实际不能正常一行显示，会出现换行情况。换行的原因在于换行制表符产生的空隙。

解决方案：父元素:font-size: 0；或者标签紧挨着不换行；

## 4、响应式布局方案

- 媒体查询`@media screen and (max-width: 320px){}`
- 百分比（需要知道百分比（%）到底是谁的百分比-大部分相对于祖先元素）
  - padding和margin的百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width
  - border-radius的百分比，相对于自身的宽度width
- rem单位（只相对于浏览器的根元素（HTML元素）的font-size） - em是根据父元素font-size
- vw/vh（相对于视窗的尺寸）

## 5、flex布局

- 容器属性
  - justify-content：主轴对齐方式
  - align-items：交叉轴对齐方式
  - flex-direction：主轴方向
  - flex-wrap：主轴上项目是否自动换行，默认nowrap，可设置为wrap
- 项目属性
  - `flex: flex-grow flex-shrink flex-basis`：表示放大比例 缩小比例 占据的主轴空间
  - flex: auto表示1 1 auto；flex: none表示 0 0 auto

## 6、BFC

常见问题：

> 1、BFC触发条件？

- overflow为hidden、scoll、auto
- display为table-cell、inline-block
- position不为relative和static（脱离文档流）
- float不为none

> 2、BFC解决的问题？

- 浮动元素使得父元素高度塌陷
- 外边距垂直方向重合问题
- 两栏自适应布局问题（左侧浮动，右边内容一多文字就会扩展到左边，形成环绕左侧的现象，需要为右侧设置BFC）

## 7、居中布局

> 修正：水平居中的盒子方法1应为父元素 text-align: center; 子元素 display: inline-block;

<img src='img/布局.png'>

## 8、三列布局

- 浮动布局 - **注意，中间布局要放在最后！！！**

```html
<style>
    .left {
        width: 200px;
        height: 50px;
        float: left;
    }

    .main {
        height: 100px;
        margin: 0 200px;
    }

    .right {
        width: 200px;
        height: 50px;
        float: right;
    }
</style>

<div class="left"></div>
<div class="right"></div>
<div class="main"></div>
```

- 定位布局 - 注意绝对定位不仅要设置left/right，还要将top设置为0！！！

```html
<style>
    .container{
        position: relative;
    }

    .left {
        width: 200px;
        height: 50px;
        position: absolute;
        left: 0;
        top: 0;
    }

    .main {
        height: 100px;
        margin: 0 200px;
    }

    .right {
        width: 200px;
        height: 50px;
        position: absolute;
        right: 0;
        top: 0;
    }
</style>

<div class="container">
    <div class="left"></div>
    <div class="main"></div>
    <div class="right"></div>
</div>
```

- flex布局 - 建议采用该方法！！！

```html
<style>
    .container{
        display: flex;
    }

    .left {
        width: 200px;
        height: 50px;
    }

    .main {
        height: 100px;
        width: 100%;
    }

    .right {
        width: 200px;
        height: 50px;
    }
</style>

<div class="container">
    <div class="left"></div>
    <div class="main"></div>
    <div class="right"></div>
</div>
```

## 9、等高布局

父元素设置：`overflow: hidden;`，需要等高的子元素均设置：`margin-bottom:-999999px;padding-bottom:999999px;`即可！

## 10、浮动

常见问题：

> 1、清除浮动的方法？

关键在于clear:both添加在哪？

- 浮动子元素后添加div，并设置clear:both样式 - 存在问题是额外增加了一个无意义的标签，有点占用资源；
- 父元素添加:after伪类，并设置clear:both样式
- 父元素设置overflow:hidden样式，BFC - 存在问题是若float元素高度比父元素大那么超出的部分会被隐藏；

> 2、设置元素浮动后，该元素的 display 值会如何变化？

- 设置元素浮动后，该元素的 display 值自动变成 block


## 11、元素隐藏

`visibility：hidden`， `opacity:0` ，`display：none` —— 是否占空间？绑定事件能否触发？

- visibility=hidden：元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件，只会引起页面重绘，子元素可以设置visibility:visible显示出来。
- opacity=0：透明度为0，元素隐藏起来了，但不会改变页面布局，绑定的事件也能正常触发，只会引起页面重绘。
- display:none：元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样，它会产生回流和重绘。

## 12、transition、transform和animation

常见问题：

> 1、transition、transform和animation的区别？

- transition（过渡）——当目标元素上的CSS属性发生变化时，按设定的效果进行过渡`transition: property duration timing-function delay;`
- transform（变换）——应用于元素的2D或3D转换`transform: rote(30deg);`
- animation（动画）——`animation: 动画名 持续时间 其他子属性;` 具体的动画效果在`@keyframes 动画名{form:{},to{}}`实现

```css
animation: 动画名 持续时间 其他子属性;

/*注意，动画的实际表现是由 @keyframes规则实现*/
@keyframes 动画名{
  from{css-styles};
  to{css-styles;};
  /* 也可以写成百分比的形式25%，50%，75%等逐步定义动画的表现 */
}
```

## 13、其他

常见问题：

> 1、盒模型——content box和border-box？

- content box的宽度为content，border-box的宽度为content+padding+border；

> 2、CSS背景的填充范围？

- 背景颜色填充的范围是内容、内边距和边框区；边框设置为虚线时可验证； border-box；
- 背景图片填充默认范围是内容、内边距和边框区；但是！！！设置了no-repeat，其填充的位置是padding与border的边界点(即不包括border)，这个时候设置position就要考虑这个填充范围。

> 3、双边距重叠问题？

- margin值均为正数或负数，则取绝对值最大的值；margin值为一正或一负，则取两者相加的值；

> 4、一个高度自适应的 div，里面有两个 div，一个高度 100px，如何使另一个填满剩下的高度？

- 方案 1： .sub { height: calc(100%-100px); }
- 方案 2： .container { position:relative; } .sub { position: absolute; top: 100px; bottom: 0; }
- 方案 3： .container { display:flex; flex-direction:column; } .sub { flex:1; }



# 四、HTML知识

## 1、语义结构化

<img src='img/H5结构语义化.png' />

## 2、Meta标签

常见问题：

> 1、常用meta标签？

主要分为两种：

- ＜meta http-equiv=”参数” content=”参数变量值”＞

```html
1、用于设定网页字符集，便于浏览器解析与渲染页面
<meta http-equiv="content-Type" content="text/html;charset=utf-8">
2、指导浏览器如何缓存某个响应以及缓存多长时间。
<meta http-equiv="cache-control" content="no-cache">
3、用于设定网页的到期时间，过期后网页必须到服务器上重新传输。
<meta http-equiv="expires" content="Sunday 10 October 2020 01:00 GMT" />
4、设定cookie
<meta http-equiv="Set-Cookie" content="User=Lxxyx; path=/; expires=10-Jan-16 10:00:00 GMT">
5、网页将在设定的时间内，自动刷新并调向设定的网址。
<meta http-equiv="refresh" content="30;URL=http://www.fourdays.com/">
```

- ＜meta name=”参数” content=”具体的参数值”＞

```html
1、告诉搜索引擎网页的信息：keywords-关键字；author-作者；description-描述；copyright-版权信息；
<meta name="keywords" content="硕士生，前端">
2、视图窗口的设置信息
<meta name="viewport" content="width=device-width, initial-scale=1">
```

> 2、meta标签的作用？

meta标签提供关于HTML文档的元数据，元数据将服务于浏览器（如何布局或重载页面），搜索引擎SEO和其它网络服务等。

## 3、img标签

常见问题：

> 1、img 中 title 属性和 alt 属性的区别？

- 鼠标放上去会出现 title 信息
- 当图片不输出信息的时候，会显示 alt 信息

## 4、页面通信

常见问题：

> 1、如何实现浏览器内多个标签页之间的通信? ？

- localstorge通过`localStorage.setItem("key", value)`改变，另一页面监听storage事件即可获取信息；
- cookie通过`document.cookie="key="value; `改变，另一页面通过setInterval轮询获取信息；
- websocket

## 5、manifest

原理：HTML5 的离线存储是基于一个新建的.appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

使用：

```html
<html lang="en" manifest="index.manifest">
```

manifest文件：

```
CACHE MANIFEST
#v1.0

CACHE:    ->说明哪些文件可以离线缓存
js/app.js
css/style.css

NETWORK:  ->说明哪些文件必须联网才能获取
assets/logo.png

FALLBACK: ->指定了一个后备页面，当资源无法访问时，浏览器会使用该页面 
/html5/ /404.html
```

## 6、浏览器渲染过程

常见问题：

> 1、浏览器渲染过程？

 - 解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js
 - CSS 文件下载完成，开始构建 CSSOM(CSS 树)
 - CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)
 - 布局(Layout)：计算出每个节点在屏幕中的位置
 - 显示(Painting)：通过显卡把页面画到屏幕上

> 2、DOM树和render树的区别？

- DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素
- render树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性

## 7、form表单

常见问题：

> 1、enctype数据类型？

- `application/x-www-form-urlencoded` —— key=value&key=value 格式
- `multipart/form-data` —— 提交文件
- `text/plain` ——文本

## 8、Html5新增元素

<img src='img/H5新增.png'>

## 9、图片格式

<img src='img/图片格式.png'>

## 10、其他

常见问题：

> 1、src与href的区别？

- src(引入-img/script/iframe) + href(引用建立联系-link/a)

> 2、a标签href的几种用法？

- url地址链接 + 绝对/相对URL + `#id`锚点 + 压缩文件等



# 五、浏览器知识

## 1、Web缓存

常见问题

> 1、强缓存与协商缓存 - 详见参考[浏览器缓存](https://segmentfault.com/a/1190000008956069)

<img src='https://segmentfault.com/img/bVuuo2' />

- 强缓存字段：Expires + cache-control
- 协商缓存字段：Last-modified / If-Modified-Since + Etag / If-None-Match

> 2、除了浏览器缓存还有哪些web缓存？

- Web缓存：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存；
- 浏览器缓存： HTTP 缓存、indexDB、cookie、localstorage 、sessionstorage等；

> 3、浏览器缓存的应用？

- 如果需要少量的信息, 可以考虑使用 cookies, 如 `记住密码` 或 60 秒后 `重发验证码`
- 如果存储敏感信息, 且希望 `退出后自动清空` , 可以考虑 sessionStorage 或 cookies
- 如果需要 `记住上一步` 的表单信息, 且 `刷新` 后继续可见, 建议使用 localtorage
- 如果需要在页面间记住 `查询条件` , 可使用 sessionStorae 或 localtorage
- 如果需要跨页面 `共享数据` , 可以考虑使用 localStorage
- 如果需要缓存 `大量` 的数据, 建议使用 IndexedDB, 如 `落地页配置`
- 如果缓存的数据存在一定的 `关联关系` , 建议使用 IndexedDB

> 4、问题2延伸 - 什么是CDN？

- CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应。CDN工作流程详见[参考资料](https://www.cnblogs.com/crazylqy/p/7110156.html)。

## 2、Http协议

常见问题

> 1、浏览器输入URL到页面渲染全过程（详细）

- DNS解析
  - 浏览器缓存->系统缓存->路由器缓存->网络提供商缓存
  - `www.baidu.com`就需要递归查找 com域名下查找->baidu域名下查找->www域名下查找
- TCP三次握手
  - 浏览器->服务器：高速服务器我要发送请求了
  - 服务器->浏览器：我知道你要发送请求了，我做好准备了
  - 浏览器->服务器：我知道你准备好了，我要发送了
- 发送请求：构造HTTP请求并发送 (请求类型)
- 接收响应：也就是响应报文 (状态码)
- 解析并渲染页面(以下步骤并不一定按照顺序)
  - 遇到Html标记，调用html解析器构建DOM树
  - 遇到link或style标记，调用CSS解析器构建CSSOM树
  - 遇到script标记，调用JS解析器（绑定事件，操作修改DOM等）
  - 将DOM树和CSSOM树合并成一个渲染树render tree
  - 根据渲染树来计算布局并将每个节点绘制到屏幕上去
- TCP四次挥手
  - 浏览器->服务器：我请求（请求报文）完毕了，要关闭连接了
  - 服务器->浏览器：我知道你要关闭连接了，我接受请求（请求报文）完毕了，正在准备关闭
  - 服务器->浏览器：我发送报文（响应报文）完毕了，可以关闭了
  - 浏览器->服务器：我东西（响应报文）接受完了，我准备关闭，你也关闭吧（一般服务器先关）

> 2、HTTP协议的请求方式

详见[HTTP请求方式](#4HTTP请求方式)

> 3、常见HTTP状态码

- 1** - 收到请求，正在处理
- 2** - 请求成功（200）
- 3** - 找到资源，但需要另外的操作（304，301，302）
- 4** - 浏览器的错误（404，403）
- 5** - 服务器的错误（504）

> 4、渲染延伸 - 解析JS文件的顺序？

- `<script>`遇到 JS 就停止渲染，执行 JS 代码。
- `<script async>`异步下载JS文件不阻塞DOM解析，当下载完阻塞DOM解析转而执行JS文件
- `<script defer>`异步下载JS文件不阻塞DOM解析，HTML标签解析完成后按顺序执行JS文件

> 5、TCP/UDP的区别？

- TCP面向连接，可靠的传输，一对一
- UDP无连接，不可靠的传输，一对多等均可，面向报文，应用于视频、直播、语音等实时性较高场景

> 6、常见请求头？

<img src='img/请求头.png'>

## 3、重绘与回流

常见问题

> 1、重绘与回流(重排)的概念及发生？

- 重绘：节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，例如字体颜色，背景颜色等。
- 回流：节点的布局或者几何属性需要改变，影响布局的，例如DOM处理、位置尺寸、字体大小、窗口尺寸变化、隐藏内容等。

> 2、如何减少回流与重绘？

- 使用csstext，className一次性改变属性
- 脱离文档流修改DOM(3种方法)
- 避免使用CSS表达式，避免使用table布局等

> 3、移动标签却不导致重排的方法？

- 应用transform不会重排

## 4、HTTP请求方式

常见问题

> 1、常见的HTTP请求方式？

- 增删改查 - put，delete，post，get
- TRACE - 回显服务器收到的请求，主要用于测试或诊断
- OPTIONS - 返回服务器的相关信息，如支持的请求方式等
- CONNECT

> 2、put和post的区别？

- 创建或更新资源时，PUT可以指定资源路径，POST无法指定资源路径

> 3、get和post的区别？

- get参数通过url传递，post放在request body中
- get请求在url中传递的参数是有长度限制的，而post没有（实际是浏览器url有限制）
- get请求只能进行url编码，而post支持多种编码方式
- get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留
- get比post不安全，因为参数直接暴露在url中

> 4、post支持的编码格式

- application/x-www-form-urlencoded - 表单默认编码格式，以key1=val1&key2=val2 的方式进行编码
- multipart/form-data - 一般用来上传文件
- application/json - 消息主体是序列化后的 JSON 字符串
- text/xml

## 5、Https协议

1. 客户端（浏览器）向服务器请求https连接。
2. 服务器返回证书（公钥）到客户端。
3. 验证证书的合法性
4. 客户端随机的秘钥A（用于对称加密）。
5. 客户端用公钥对A进行加密。
6. 客户端将加密A后的密文发送给服务器。
7. 服务器通过私钥对密文进行解密得到对称加密的秘钥。
8. 客户端与服务器通过对称秘钥加密的密文通信。

## 6、Http2.0

Http2.0的特点在于：

- 二进制传输
- 多路复用
- 服务器可主动推送资源
- 头部Header压缩

## 7、浏览器对象模型BOM

BOM(浏览器对象模型)的核心是window(顶层对象)

- document 文档对象
- history - 历史记录相关的信息
- navigator - 浏览器相关的信息
- location - 当前的url相关的信息
- screen - 客户端显示屏幕的信息
- ......

## 8、cookie、session

常见问题 - [参考链接](https://juejin.im/post/5e893002f265da48094d8cd3#heading-10)：

> 1、cookie的作用域？

cookie的作用域：`Domain` 和 `Path` 标识定义了 Cookie 的作用域；以下述cookie为例`docment.cookie="name=value;domain=.google.com;path=/docs" `：

- `Domain` 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前主机(**不包含子域名**）。如果指定了`Domain`，一般包含子域名。例如：`.google.com`、`hello.google.com`、`www.hello.google.com`均匹配
- `Path`标识指定了cookie的有效访问路径。例如：`/docs`、`/docs/Web/`、`/docs/Web/HTTP`均匹配

注意cookies的域发请求时送给谁这个域就是谁的，例如A网站发送请求至B，此时的cookie的域应该是B的，而不是A 的。

>2、cookie与session的区别？

 - cookie存在客户端，session存在于服务端。
 - cookie在客户端中存放，容易伪造，不如session安全
 - session会消耗大量服务器资源，cookie在每次HTTP请求中都会带上，影响网络性能



# 六、扩展知识

## 1、性能优化

常见问题：

> 1、性能优化的方式？

- 降低请求量 - 合并资源，减少HTTP 请求数，精灵图，懒加载，gzip压缩
- 加快请求速度 - CDN 分发，预解析DNS
- 缓存 - HTTP 协议缓存请求，离线数据缓存localStorage
- 渲染 - JS/CSS优化，加载顺序，服务端渲染SSR

> 2、说下图片的懒加载和预加载？

- 图片预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染，减少等待的时间。
  - 应用场景：略缩图，点击方法时可以直接获取大图显示

- 图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片，减少请求数或延迟请求数。
  - 应用场景：滑动相册，不需要全部加载，滑动的时候加载即可

## 2、前端安全

常见问题：

> 1、CSRF跨站请求伪造和XSS跨站脚本攻击的场景和防御方案？

**CSRF跨站请求伪造** —— 详见[安全防御](../前端基础/安全防御/安全防御.md)

**XSS跨站脚本攻击** —— 详见[安全防御](../前端基础/安全防御/安全防御.md)

> 2、还有哪些web攻击方法？

**SQL注入**

 - 攻击原理：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，后台执行SQL语句时直接把前端传入的字段拿来做SQL查询。
 - 防御措施：永远不要信任用户的输入，需要过滤等操作；不要把机密信息直接存放；

**点击劫持**

 - 攻击原理：点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
 - 防御措施：X-FRAME-OPTIONS这一个 HTTP 响应头，该响应头有三个值可选，分别是`DENY`，表示页面不允许通过`iframe`的方式展示；`SAMEORIGIN`，表示页面可以在相同域名下通过`iframe`的方式展示；`ALLOW-FROM`，表示页面可以在指定来源的`iframe`中展示；

**中间人攻击**

 - 攻击原理：攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。例如使用公共wifi等。
 - 防御措施：HTTPS

## 3、SEO搜索引擎优化

常见问题：

> 1、SEO有哪些注意点？

- 合理的title、description、keywords
- 语义化的HTML代码，符合W3C规范，让搜索引擎容易理解网页
- 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下
- 少用iframe，搜索引擎不会抓取iframe中的内容
- 非装饰性图片必须加alt，例如图片，视音频等

## 4、CDN

<img src='img/cdnnocahche.png'>

1. 用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。
2. 域名解析的请求被发往网站授权DNS服务器。
3. 网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com。
4. 请求被指向CDN服务。
5. CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。
6. 用户获取响应速度最快的CDN节点IP地址。
7. 浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。
8. 如果CDN节点有资源就返回资源，如果没有资源则CDN节点回源站拉取用户所需资源。
9. 将回源拉取的资源缓存至节点。
10. 将用户所需资源返回给用户。



# 七、VUE框架

## 1、VUE生命周期

常见问题：

> 1、哪些钩子函数？

- 创建期间——beforeCreate,created,beforeMount,mounted
- 运行期间——beforeUpdate, updated
- 销毁期间——beforeDestroy,destroyed

> 2、简述生命周期？

- 创建——初始化Vue对象(date、method都还没有)->beforeCreate->date、method初始化->created->模版编译(只完成编译还没有显示到页面)->beforeMount->将编译的模版显示到页面上->mounted->创建完成
- 运行——数据改变(也就是model层data改变，页面没变)->beforeUpdate->将页面同步更新渲染->updated
- 销毁——调用销毁函数->beforeDestroy->完成销毁->destroyed

## 2、数据双向绑定原理

> 1、MVVM的原理？

详见[MVVM的原理](../前端框架/Vue/MVVM模型.md)

> 2、单向数据绑定(vuex)和双向数据绑定的区别？

**单向绑定**：把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。因此，我们不需要进行额外的DOM操作，只需要进行Model的操作就可以实现视图的联动更新。` v-bind `就是单向绑定。

**双向绑定**：把Model绑定到View的同时也将View绑定到Model上，这样就既可以通过更新Model来实现View的自动更新，也可以通过更新View来实现Model数据的更新。所以，当我们用JavaScript代码更新Model时，View就会自动更新，反之，如果用户更新了View，Model的数据也自动被更新了。`v-model`主要是用在表单元素中，实现了双向绑定。

## 3、vuex状态管理

> 1、vuex管理状态的机制？

详见[Vuex指南](../前端框架/Vue/Vuex/Vuex指南.md)

## 4、Vue组件通信

- 父传子 - 通过props获取信息

```vue
// 父组件
<template>
    <child :obj="data"></child>
</template>
<script>
    import child form "./child"
    exprot default{
        name:"parent",
        data(){
            return {
                data:"我要向子组件传递数据"
            }
        },
        components:{
            child
        }
    }
</script>

// 子组件
<template>
    <div>{{data}}</div>
</template>
<script>
    exprot default{
        name:"child",
        //接受父组件传值
        props:["data"]
    }
</script>
```

- 子传父 - 通过this.$emit()

```vue
// 子组件
<template>
    <button @click="sendMsg">点击</button>
</template>
<script>
    exprot default{
        name:"child",
        methods: {
          sendMsg:function(){
            this.$emit('show-msg','hello world!')
          }
        }
    }
</script>

// 父组件
<template>
		{{msg}}
    <child :show-msg="showMsg"></child> 
</template>
<script>
    import child form "./child"
    exprot default{
        name:"parent",
        data(){
            return {
              msg:''
            }
        },
        components:{
            child
        },
        methods:{
          showMsg: function(data){
            this.msg = data
          }
        }  
    }
</script>
```

## 5、Vue路由

常见问题：

> 1、route(路由信息对象)和 router(路由实例对象)的区别？

- route是路由信息对象，包括path，params，hash，query，fullPath，matched，name等路由信息参数。 

- router是路由实例对象，包括路由的跳转方法，钩子函数等。

> 2、vue路由传参的方法？

略。

> 3、路由跳转的方法？

- 声明式（标签跳转）：

```
// 1、使用路径 
<router-link :to="{path:'/home'}">
// 2、使用name
<router-link :to ="{name:'home', params: {id:1}}"> 
```

- 编程式（ js 跳转）： 

```
this.$router.push({name:'home'})
this.$router.push({path:'/home'})
this.$router.push({path:'/home',query: {id:'1'}})
this.$router.push({name:'home',query: {id:'1'}})
this.$router.push({name:'home',params: {id:'1'}}) // 只能用 name
// query类似get, 跳转之后页面url后面会拼接参数,类似?id=1; params类似 post, 跳转之后页面 url后面不会拼接参数;
```

 注意编程式还可以使用`this.$router.replace()`和`this.$router.go(n)`

> 4、`this.$router.push`，`this.$router.replace`和`this.$router.go(n)`的区别

- this.$router.push：跳转到指定url路径，并向history栈中添加一个记录
- this.$router.replace：跳转到指定url路径，但并不向history栈中添加一个记录
- this.$router.go(n)：向前或者向后跳转n个页面

> 5、什么是路由懒加载？

以前使用路由都需要先导入组件

```js
import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'

Vue.use(Router)

export default new Router({
    routes: [
        {
            path: '/',
            name: 'HelloWorld',
            component: HelloWorld
        }
    ]
})
```

使用路由懒加载后就按需导入即可

```js
import Vue from 'vue'
import Router from 'vue-router'
/* 此处省去之前导入的HelloWorld模块 */
Vue.use(Router)

export default new Router({
    routes: [
        {
            path: '/',
            name: 'HelloWorld',
            component: resolve=>(require(["@/components/HelloWorld"],resolve))
        }
    ]
})
```

## 6、Vue指令

常见问题：

> 1、常见vue指令？

- v-bind
- v-model
- v-if
- v-show
- v-for
- v-on

> 2、v-if和v-show的区别？

- v-if是动态的向DOM树内添加或者删除DOM元素；
- v-show是通过设置DOM元素的display样式属性控制显隐；

> 3、v-bind和v-model的区别？

- v-bind绑定数据和属性以及表达式，缩写为`:`；
- v-model使用在表单中，实现双向数据绑定的，在表单元素外使用不起作用；

## 7、axios

常见问题：

> 1、简述使用axios实现登陆功能？

略。



# 八、其他工具

## 1、webpack

详见



# 九、职业发展

## 1、专业技能

详见[前端工程师必备技能](https://img-blog.csdnimg.cn/20190210014429562.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYXh1ZTE2OA==,size_16,color_FFFFFF,t_70)。

- 编程语言 - Javascript/python
- 前端规范 - html5/CSS3/ES6等
- 前端框架 - vue/jquery/react等
- 后端服务器相关知识
- 基础的设计能力和需求分析的能力
- 浏览器的兼容性处理
- 网络安全CSRF/XSS等
- 测试和性能

## 2、项目中遇到的问题

- 课堂教学辅助系统 - 在线考试实时更新成绩 / excel导入及导出问题 / elemetnUI相关问题等
- App评论数据分析系统 - Echarts相关问题等



------

如果发现本项目有错误，欢迎提交 issues 指正。
# 前端-面试知识总结

简介：本文为本人2020秋招前端面试相关问题总结，完整笔记详见[Github](https://github.com/MrEnvision/Front-end_learning_notes)

作者：[Envision](https://github.com/MrEnvision)          联系邮箱：[EnvisionShen@gmail.com](mailto:EnvisionShen@gmail.com)

参考资料：[Front-End-Interview-Notebook](https://github.com/CavsZhouyou/Front-End-Interview-Notebook)



## 题目

HTML

1. HTML 、XML 和 XHTML 的区别？
2. 行内元素与块级元素的区别？
3. 引入CSS样式的link与@import的区别？
4. 对浏览器的理解？
5. 浏览器的渲染原理？
6. 渲染页面时常见哪些不良现象？
7. async 和 defer 的作用与区别？
8. 重绘与回流？
9. 如何减少回流？
10. HTML语义化的理解？
11. 语义化标签哪些？
12. 前端SEO？
13. HTML5 的离线储存怎么使用？
14. 浏览器端的存储技术有哪些？
15. cookie、localstorage 、sessionstorage的区别？
16. 如何在浏览器多个标签页内通信？
17. 如何在页面上实现一个圆形的可点击区域？
18. Canvas 和 SVG 有什么区别？
19. link标签与meta标签？
20. head中有哪些标签？
21. Html 规范中为什么要求引用资源不加协议头`http`或者`https`？
22. 前端优化？

CSS

1. CSS 的盒子模型？
2. CSS 选择器？
3. CSS权重（优先级）？
4. 伪类与伪元素的区别？
5. CSS 样式继承？
6. a标签的伪类？
7. 居中布局？
8. display 的值有哪些以及作用？
9. position 的值及其定位点？
10. flex布局？
11. 用纯 CSS 创建一个三角形的原理是什么？
12. 等高布局的方法？
13. li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
14. 如何让去除 inline-block 元素间间距？
15. 什么是包含块?
16. width:auto 和 width:100% 的区别？
17. 绝对定位元素与非绝对定位元素的百分比计算的区别？
18. display、position 和 float 的相互关系？
19. margin 重叠理解与解决？
20. BFC 规范（块级格式化上下文 block formatting context）的理解？
21. 清楚浮动的方式以及为什么需要清除浮动？
22. 媒体查询的理解？
23. 浏览器是怎样解析 CSS 选择器的？
24. 抽离样式模块也就是 CSS 分类？
25. margin 和 padding 分别适合什么场景使用？
26. 为什么不建议使用统配符初始化 css 样式？
27. 元素百分比的相对参考点？
28. font-style 属性中 italic 和 oblique 的区别？
29. 设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？
30. 一个高度自适应的 div，里面有两个 div，一个高度 100px，如何使另一个填满剩下的高度？
31. 阐述一下 CSSSprites？
32. CSS 中出现 height 为 100% 失效的原因？
33. animation、transition、transform、translate 的区别？
34. margin:auto 的填充规则？
35. line-height/font-size理解？
36. 图片格式 - 7种？
37. absolute定位对overflow:hidden的影响？
38. relative定位的注意点？
39. 层叠规则？
40. letter-spacing与word-spacing的区别？
41. 单行/多行文本溢出省略号的处理？
42. 常见的元素隐藏方式？
43. CSS布局？
44. 宽高自适应的正方形？（自适应比例矩形）
45. 双飞翼布局/圣杯布局？
46. 百分比总结？
47. CSS优化？

JS

1. JS数据类型？
2. null 和 undefined 的区别？
3. 如何安全获取undefined？
4. 数字不同进制的表示方式？
5. 原型、原型链？
6. 类型转换？
7. 布尔值的隐式强制转换发生在哪些？
8. 如何使字符串转数字？
9. 生成随机数的方法？
10. 如何实现数组的随机排序？
11. 对象的继承有哪几种方法？
12. this的指向？
13. 改变函数内部 this 指针的指向函数？
14. 事件是什么？
15. 三种事件模型？
16. 什么是事件委托？
17. 如何阻止冒泡事件和默认事件？
18. 什么是闭包？
19. 作用域链与原型链的区别？
20. 判断一个对象是否属于一个类？判断数据的类型？自定义类型判断？
21. instanceof 的原理？
22. new操作符干了什么？
23. Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？
24. [].forEach.call()`的理解？
25. JS延迟加载的方法？
26. AJAX的主要步骤？
27. 模块化规范？
28. documen.write 和 ele.innerHTML区别？
29. DOM查找的方法？
30. innerHTML 与 outerHTML 的区别？
31. 类数组对象？
32. 垃圾回收机制？
33. 如何判断当前脚本是运行在浏览器还是node环境中？
34. 节流与防抖？
35. ==、===、Object.is区别？
36. JS事件循环机制？
37. 监听对象属性的改变的方法？
38. 获取元素位置大小的方法？
39. 谈谈webpack？
40. 异步编程的方式？
41. JS 动画与 CSS 动画区别？
42. 图片的懒加载和预加载？
43. Set 和 WeakSet 结构？Map 和 WeakMap 结构？
44. proxy与reflect对象？
45. promise对象？手写Promise？
46. 使用闭包实现每隔一秒打印 1,2,3,4
47. 手写一个JSONP-跨域？
48. 静态方法、公有方法、私有方法的区别？
49. 函数声明与函数表达式声明的区别？
50. 一个列表，假设有 100000 个数据，这个该怎么办？
51. 设计模式？
52. 使用setTimeout模拟setInterval？
53. 数组/String相关方法？
54. 深浅拷贝的实现？
55. call、apply、bind手写？
56. 函数柯里化







## 1） HTML

### 1. HTML 、XML 和 XHTML 的区别？

```
1、HTML 超文本标记语言（Hyper Text Markup Language） —— 旨在显示信息，不区分大小写，标签固定且有限；
2、XML 可扩展标记语言（Extensible Markup Language）—— 旨在传输信息，区分大小写，标签可以自己创建；
3、XHTML 可扩展超文本标记语言（Extensible Hyper Text Markup Language）—— 比 HTML 更加严格，标签必须被正确地嵌套，标签必须闭合，标签必须小写，文档必须有根元素 <html>；
```

### 2. 行内元素与块级元素的区别？

```
常见的行内元素有 a b span img strong sub sup button input label select textarea；
常见的块级元素有 div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p；
1、格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行；
2、内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素；
3、布局上，默认情况下，行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响（左右有效，但上下会有视觉效果比如border被撑开）。
```

### 3. 引入CSS样式的link与@import的区别？

```
1、@import 只有导入样式表的作用；link 不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。
2、加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。
3、兼容性区别
```

### 4. 对浏览器的理解？

```
浏览器的主要功能是将用户选择的 web 资源从服务器请求，然后呈现在浏览器窗口中。简单来说浏览器可以分为两部分：shell 和 内核。shell 是指浏览器的外壳，例如菜单，工具栏等提供给用户操作，而内核主要分为渲染引擎和 JS 引擎。

浏览器内核：渲染引擎和 JS 引擎。渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容，默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。JS 引擎：解析和执行 javascript 来实现网页的动态效果。
```

### 5. 浏览器的渲染原理？

> 参考资料：[《浏览器渲染原理》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)  [《深入浅出浏览器渲染原理》](https://blog.fundebug.com/2019/01/03/understand-browser-rendering/)

```
1、解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js
2、CSS 文件下载完成，开始构建 CSSOM(CSS 树)
3、CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)
4、布局：计算出每个节点在屏幕中的位置
5、显示：遍历渲染树并调用渲染对象的 paint 方法将内容显示在屏幕上

浏览器的渲染相关问题：
- 渲染过程中遇到 JS 文件怎么处理？ —— 阻塞文档的解析并加载、解析 JS 文件，async 和 defer 属性的作用。
- css是否阻塞html解析、渲染？ —— css加载不会阻塞DOM树的解析；css加载会阻塞DOM树的渲染；css加载会阻塞后面js语句的执行（JavaScript 脚本执行时可能请求样式信息）
```

### 6. 渲染页面时常见哪些不良现象？

```
1、FOUC（样式闪烁）：在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。
- 产生原因：使用import方法导入样式表；将样式表放在页面底部 ；有几个样式表，放在html结构的不同位置。
- 解决方法：css使用 link 标签将样式表放在顶部。

2、白屏：页面迟迟未渲染出来。
- 产生原因：JS 文件放在头部，脚本的加载会阻塞后面文档内容的解析；有些浏览器渲染机制（比如chrome）要先构建 render tree 再进行渲染，CSS 放在末尾的话，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏。
- 解决方法：尽量把 JavaScript 放入页面body底部。
```

### 7. async 和 defer 的作用与区别？

```
1、渲染过程中遇到 JS 就停止渲染，执行 JS 代码；
2、async 异步下载 JS 文件不阻塞 DOM 解析，当下载完阻塞 DOM 解析转而执行 JS 文件；
3、defer 异步下载 JS 文件不阻塞 DOM 解析，HTML 标签解析完成后按顺序执行 JS 文件；
```

### 8. 重绘与回流？

> 参考资料： [《浏览器的回流与重绘》](https://juejin.im/post/5a9923e9518825558251c96a)

```
- 重绘：节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，例如字体颜色，背景颜色等。
- 回流：节点的布局或者几何属性需要改变，影响布局的，例如DOM处理、位置尺寸、字体大小、窗口尺寸变化、隐藏内容等。

常见触发回流情况（元素的位置和尺寸大小更改）：
（1）添加或者删除可见的 DOM 元素；
（2）元素尺寸改变 -- 边距、填充、边框、宽度和高度
（3）内容变化，比如用户在 input 框中输入文字
（4）浏览器窗口尺寸改变 -- resize事件发生时
（5）计算 offsetWidth 和 offsetHeight 属性
（6）设置 style 属性的值
（7）当你修改网页的默认字体时（元素字体大小变化）
（8）页面首次渲染
（9）激活CSS伪类（例如：:hover）
```

### 9. 如何减少回流？

```
1、不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
2、把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM；元素设置display: none，操作结束后再把它显示出来
3、不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。
```

### 10. HTML语义化的理解？

```
（1）用正确的标签做正确的事情。
（2）html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;
（3）即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;
（4）搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO ;
（5）使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
```

### 11. 语义化标签哪些？

```
衍生问题：b 与 strong 的区别和 i 与 em 的区别？
```

<img src='img/语义化标签.png'>

### 12. 前端SEO？

```
（1）合理的 title、description、keywords （meta标签）
（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页
（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取
（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容
（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容
（6）非装饰性图片必须加 alt
（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标
```

### 13. HTML5 的离线储存怎么使用？

> 参考资料： [《HTML5 离线缓存-manifest 简介》](https://yanhaijing.com/html/2014/12/28/html5-manifest/) [《有趣的 HTML5：离线存储》](https://segmentfault.com/a/1190000000732617)
>
> 1、创建一个和 html 同名的 manifest 文件
>
> ```
> CACHE MANIFEST
> #version 1.3
> 
> CACHE: - 表示需要离线存储的资源列表
> js/app.js
> css/style.css
> 
> NETWORK: - 表示只有在线的情况下才能访问的资源列表
> resourse/logo.png
> 
> FALLBACK: - 表示如果访问第一个资源失败，那么就使用第二个资源来替换他
> / /offline.html
> ```
>
> 2、在html页面头部加入一个 manifest 的属性
>
> ```
>  <html lang="en" manifest="index.manifest">
> ```

### 14. 浏览器端的存储技术有哪些？

>cookie、localstorage 、sessionstorage 和 indexDB（大规模数据存储）等。

### 15. cookie、localstorage 、sessionstorage的区别？

>1. 存储大小
>-  cookie：数据大小不能超过4 k 。
>-  sessionStorage 和 localStorage：可以达到 5M 或更大。
>2. 有期时间
>-  localStorage：存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
> -  sessionStorage：数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
> -  cookie：设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
>3. 作用域：
>- sessionStorage：只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
> - localStorage：在所有同源窗口中都是共享的。
> - cookie：在所有同源窗口中都是共享的。

### 16. 如何在浏览器多个标签页内通信？

```
原理：本质上都是通过中介者模式来实现，因为标签页之间没法直接通信，因此让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

（1）使用 websocket 协议： websocket 协议可以实现服务器推送，服务器就可以用来当做这个中介者，标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
（2）用 ShareWorker 的方式：shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程，共享线程就可以充当中介者的角色，标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
（3）使用 localStorage 的方式：localStorage 对象充当中介者的角色，在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据localStorage.setItem("key", value)，就可以通过这个监听storage事件来获取到数据。（只能实现同一浏览器相同域名、相同协议、相同端口下的多个标签页之间的通信）
（4）使用 postMessage 方法
```

### 17. 如何在页面上实现一个圆形的可点击区域？

```
（1）纯 html 实现 - <map> 标签用来定义一个客户端图像映射，<area> 标签用来定义图像映射中的区域
（2）纯 css 实现 - 使用 border-radius实现圆形区域
（3）纯 JS 实现 - 通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内
```

### 18. Canvas 和 SVG 有什么区别？

```
Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。注意，<canvas> 元素本身并没有绘制能力，需要借助JS来进行绘制。

SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数，并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。
```

### 19. link标签与meta标签？

> link 标签定义文档与外部资源的关系，常用于引入样式表和 icon 图标：
>
> ```html
> <link rel="stylesheet" type="text/css" href="*.css"/>
> <link rel="icon" href="/favicon.ico">
> ```
>
> meta标签提供关于HTML文档的元数据，元数据将服务于浏览器（如何布局或重载页面），搜索引擎SEO和其它网络服务等。
>
> ```html
> <meta charset=’utf-8′>    声明文档使用的字符编码
> 
> ＜meta http-equiv=”参数” content=”参数变量值”＞
> <meta http-equiv="content-Type" content="text/html;charset=utf-8"> <!--设定网页字符集，便于浏览器解析与渲染页面--> 
> <meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/> <!--优先使用 IE 最新版本和 Chrome-->
> 
> ＜meta name=”参数” content=”具体的参数值”＞
> <meta name="viewport" content="width=device-width, initial-scale=1"> <!--视图窗口的设置信息--> 
> <meta name=”description” content=”不超过150个字符”/> <!--页面描述-->
>  <meta name=”keywords” content=””/> <!--页面关键词者-->
> ```
>
> 参考资料： [《Meta 标签用法大全》](http://www.cnblogs.com/qiumohanyu/p/5431859.html)  [面试知识总结](面试知识总结.md)的Meta标签部分

### 20. head中有哪些标签？

```
<title> <link> <meta> <script> <style> <base>
```

注：`<base>` 标签为页面上的所有链接规定默认地址或默认目标。

### 21. Html 规范中为什么要求引用资源不加协议头http/https？

```
如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，因此不如省略 URL 的协议声明，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源
```

### 22. 前端优化？

```
第一个方面是页面的内容方面

 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
 （3）通过设置缓存策略，对常用不变的资源进行缓存。
 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

第二个方面是服务器方面

 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

第三个方面是 CSS 和 JavaScript 方面

 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
 （2）避免使用 @import 标签。
 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。
```



## 2）CSS

### 1. CSS 的盒子模型？

```
盒模型都是由四个部分组成的，分别是margin、border、padding和content。IE盒模型（border-box）、W3C标准盒模型（content-box）区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
```

### 2. CSS 选择器？

```
（1）id选择器（#myid）
（2）类选择器（.myclassname）
（3）标签选择器（div,h1,p）
（4）属性选择器（a[rel="external"]）
（5）伪类选择器（a:hover,li:nth-child）
（6）伪元素选择器（::before、::after）
（7）通配符选择器（*）

（8）后代选择器（h1 p）
（9）相邻后代选择器（子）选择器（ul>li）
（10）兄弟选择器（li~a）
（11）相邻兄弟选择器（li+a）
```

### 3. CSS权重（优先级）？

```
10000 - !improtant
1000 - 行间样式
100 - ID
10 - 类选择器、属性选择器或伪类
1 - 标签和伪元素
0 - 通配符
```

### 4. 伪类与伪元素的区别？

> 参考资料： [《伪类与伪元素》](http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/)

```
:伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。
::伪元素用于创建一些不在文档树中的元素，并为其添加样式。
```

### 5. CSS 样式继承？

> 参考资料：[《CSS 有哪些属性可以继承？》](https://www.jianshu.com/p/34044e3c9317)

```
1、字体系列属性：font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust
2、文本系列属性：text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color
3、表格布局属性：caption-sideborder-collapseempty-cells
4、列表属性：list-style-type、list-style-image、list-style-position、list-style
5、光标属性：cursor
6、元素可见性：visibility
```

### 6. a标签的伪类？

```
注意顺序：love and hate： link visited  hover active 
```

### 7. 居中布局？

```
补充：盒子固定宽度，可以通过 margin: 0 auto; 实现水平居中；
修正：水平居中的盒子方法1应为父元素 text-align: center; 子元素 display: inline-block;
```

<img src='img/布局.png'>

### 8. display 的值有哪些以及作用？

```
block - 块类型，默认宽度为父元素宽度，可设置宽高，换行显示。
inline - 行内元素类型，默认宽度为内容宽度，不可设置宽高，同行显示。
inline-block - 默认宽度为内容宽度，可以设置宽高，同行显示。
inherit - 从父元素继承display属性的值。
none - 元素不显示，并从文档流中移除。
```

### 9. position 的值及其定位点？

```
- 默认static
- 绝对定位absolute - 相对于前一个非static定位的父元素，脱离文档流
- 相对定位relative - 相对于自身原来位置，未脱离文档流
- 固定定位fixed - 相对于可视窗口而言
- 粘性定位sticky - 应用于表头锁定、导航栏固定、图片堆叠等
```

### 10. flex布局？

> 参考资料： [《Flex 布局教程：语法篇》](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html) [《Flex 布局教程：实例篇》](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)

```
flex 布局是 CSS3 新增的一种布局方式，我们可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用 flex-direction 来指定主轴的方向。我们可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。

对于容器中的项目，我们可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例。还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例。
```

### 11. 用纯 CSS 创建一个三角形的原理是什么？

```
采用的是相邻边框连接处的均分原理。将元素的宽高设为0，只设置 border，把任意三条边隐藏掉（颜色设为 transparent ），剩下的就是一个三角形。
```

### 12. 等高布局的方法？

> 参考资料： [《前端应该掌握的 CSS 实现多列等高布局》](https://juejin.im/post/5b0fb34151882515662238fd) [《CSS：多列等高布局》](https://codepen.io/yangbo5207/post/equh)

```
（1）负margin-bottom和正padding-bottom实现。(注意，父元素要设置 overflow:hidden;)
（2）flex布局，项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度。
（3）table与grid布局，略。
（4）JS判断最大高度并设置
```

### 13. li 与 li 之间有看不见的空白间隔是什么原因引起的？

### 14. 如何让去除 inline-block 元素间间距？

> 参考资料：[《去除 inline-block 元素间间距的 N 种方法》](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/)

```
原因：浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，
这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

方法：（1）将所有<li>写在同一行；（2）将<ul>内的字符尺寸直接设为0，即font-size:0，其他内容再设置字体大小；（3）为<li>设置float:left。
```

### 15. 什么是包含块?

```
（1）根元素（一般是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。
（2）如果元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的contentbox边界形成。
（3）如果元素position:fixed，则“包含块”是“初始包含块”。
（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立。
```

### 16. width:auto 和 width:100% 的区别？

```
（1）width: auto 时，父元素宽度 = 子元素 width + padding-left/right + border-left/right + margin-left/right，因此子元素的宽度会自动调节，不会出现溢出父元素的情况。
（2）width: 100% 时，子元素宽度即为父元素的宽度，因此 width:100% 会发生内容溢出父节点的情况，会产生不良的影响。
```

### 17. 绝对定位元素与非绝对定位元素的百分比计算的区别？

```
（1）绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。
（2）非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。
```

### 18. display、position 和 float 的相互关系？

> 参考资料： [《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》](https://www.cnblogs.com/jackyWHJ/p/3756087.html)

<img src='http://www.w3help.org/zh-cn/kb/009/009/display_float_position.png' alt=''>

```
总结： "position:absolute" 和 "position:fixed" 优先级最高，有它存在的时候，浮动不起作用，'display' 的值也需要调整； 其次，元素的 'float' 特性的值不是 "none" 的时候或者它是根元素的时候，调整 'display' 的值； 最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display' 特性值同设置值。
```

### 19. margin 重叠理解与解决？

```
理解：margin值均为正数或负数，则取绝对值最大的值；margin值为一正或一负，则取两者相加的值；

解决：
（1）相邻兄弟元素margin合并 —— 其中一个设置BFC
（2）父元素和第一个/最后一个子元素的margin合并 —— 
		对于margin-top合并，可以进行如下操作（满足一个条件即可）：
			•父元素设置为块状格式化上下文元素；
			•父元素设置border-top值；
			•父元素设置padding-top值；
			•父元素和第一个子元素之间添加内联元素进行分隔。
		对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：
			•父元素设置为块状格式化上下文元素；
			•父元素设置border-bottom值；
			•父元素设置padding-bottom值；
			•父元素和最后一个子元素之间添加内联元素进行分隔；
			•父元素设置height、min-height或max-height。
（3）空块级元素的自身margin-top&bottom合并 —— 
		•设置垂直方向的border；
		•设置垂直方向的padding；
		•里面添加内联元素（直接Space键空格是没用的）；
		•设置height或者min-height。
```

### 20. BFC 规范（块级格式化上下文 block formatting context）的理解？

> 参考资料： [《深入理解 BFC 和 MarginCollapse》](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html) [《前端面试题-BFC（块格式化上下文）》](https://segmentfault.com/a/1190000013647777)

```
BFC指的是块级格式化上下文，一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也
不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。

创建BFC（简单记忆脱离文档流的方法即可，但实际不是哦！）
（1）overflow＝hidden|auto或scroll(≠visible)
（2）浮动元素float＝left|right或inherit（≠none）
（3）绝对定位元素position＝absolute或fixed
（4）display＝inline-block|flex|inline-flex|table-cell或table-caption
（5）根元素或包含根元素的元素

作用：
（1）浮动元素使得父元素高度塌陷
（2）外边距垂直方向重合问题
（3）两栏自适应布局问题（左侧浮动，右边内容一多文字就会扩展到左边，形成环绕左侧的现象，需要为右侧设置BFC）

衍生问题：overflow: hidden 来实现BFC会产生什么问题？例如浮动元素的父元素设置 overflow: hidden，则float元素高度比父元素大那么超出的部分会被隐藏。
```

### 21. 清楚浮动的方式以及为什么需要清除浮动？

```
原因：浮动的元素会导致高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。

方法：
（1）浮动子元素后添加div，并设置clear:both样式 - 存在问题是额外增加了一个无意义的标签，有点占用资源；
（2）父元素添加:after伪类，并设置clear:both样式
（3）父元素设置overflow:hidden样式，BFC - 存在问题是若float元素高度比父元素大那么超出的部分会被隐藏；
```

### 22. 媒体查询的理解？

> 语法：
>
> ```css
> @media mediatype and (media feature) {
>     CSS-Code;
> }
> ```
>
> mediatype：
>
> - screen：用于电脑屏幕，平板电脑，智能手机等。
> - print：用于打印机和打印预览
> - all：用于所有设备
>
> media feature（常用宽度来判断，实际还有很多属性特征可用于查询），参考[CSS3 @media 查询](https://www.runoob.com/cssref/css3-pr-mediaquery.html)：
>
> ```css
> /* Extra small devices (phones, 600px and down) */
> @media only screen and (max-width: 600px) {
>     .example {background: red;}
> }
> 
> /* Small devices (portrait tablets and large phones, 600px and up) */
> @media only screen and (min-width: 600px) {
>     .example {background: green;}
> }
> 
> /* Medium devices (landscape tablets, 768px and up) */
> @media only screen and (min-width: 768px) {
>     .example {background: blue;}
> } 
> 
> /* Large devices (laptops/desktops, 992px and up) */
> @media only screen and (min-width: 992px) {
>     .example {background: orange;}
> } 
> 
> /* Extra large devices (large laptops and desktops, 1200px and up) */
> @media only screen and (min-width: 1200px) {
>     .example {background: pink;}
> }
> ```

### 23. 浏览器是怎样解析 CSS 选择器的？

```
注意哦，解析是从右往左的。样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。因为如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，最后有很多都是无用的。
```

### 24. 抽离样式模块也就是 CSS 分类？

> 参考资料： [《CSS 规范-分类方法》](http://nec.netease.com/standard/css-sort.html)

```
我们按照CSS的性质和用途，将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。
（1）公共型样式：包括了以下几个部分：“标签的重置和设置默认值”、“统一调用背景图和清除浮动或其他需统一处理的长样式”、“网站通用布局”、“通用模块和其扩展”、“元件和其扩展”、“功能类样式”、“皮肤类样式”。
（2）特殊型样式：当某个栏目或页面的样式与网站整体差异较大或者维护率较高时，可以独立引用一个样式：“特殊的布局、模块和元件及扩展”、“特殊的功能、颜色和背景”，也可以是某个大型控件或模块的独立样式。
（3）皮肤型样式：如果产品需要换肤功能，那么我们需要将颜色、背景等抽离出来放在这里。
```

### 25. margin 和 padding 分别适合什么场景使用？

```
margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。
（1）何时应当使用margin：
	•需要在border外侧添加空白时。
	•空白处不需要背景（色）时。
	•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。
（2）何时应当时用padding：
	•需要在border内测添加空白时。
	•空白处需要背景（色）时。
	•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。
```

### 26. 为什么不建议使用统配符初始化 css 样式？

```
采用*{pading:0;margin:0;}的通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间。
```

### 27. 元素百分比的相对参考点？

```
（1）如果是宽高的话，是相对于包含块的宽高。
（2）如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。
```

### 28. font-style 属性中 italic 和 oblique 的区别？

```
italic和oblique这两个关键字都表示“斜体”的意思。它们的区别在于，italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。
```

### 29. 设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？

> 参考资料：[《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》](https://www.cnblogs.com/libin-1/p/7148377.html) [《前端工程师需要明白的「像素」》](https://www.jianshu.com/p/af6dad66e49a) [《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》](https://github.com/jawil/blog/issues/21) [《前端开发中像素的概念》](https://github.com/wujunchuan/wujunchuan.github.io/issues/15)

```
设备像素指的是物理像素（一般就是分辨率），设备像素不可变。CSS 像素是一个相对单位，dpr = 物理像素 / CSS像素，一般的 pc 屏幕，dpr = 1。ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。
```

### 30. 高度自适应的 div里面有两个 div，一个高 100px，如何使另一个填满剩下高度？

```
（1）flex 布局。设置主轴为竖轴，并且第二个 div 的 flex-grow 为1，使其自动填充剩余空间。
（2）绝对定位。外层 div 使用 position：relative，高度自适应的 div 使用 position:absolute; top:100px; bottom:0; left:0; right:0;
```

### 31. 阐述一下 CSSSprites？

```
将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background-repeat，background-position 的组合进行背景定位。利用 CSSSprites 能很好地减少网页的 http 请求，从而很好的提高页面的性能；CSSSprites 能减少图片的字节。

优点：
减少HTTP请求数，极大地提高页面加载速度；
增加图片信息重复度，提高压缩比，减少图片大小；
更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现；

缺点：
图片合并麻烦；
维护麻烦，修改一个图片可能需要重新布局整个图片，样式；
```

### 32. CSS 中出现 height 为 100% 失效的原因？

```
% 是一个相对父元素计算得来的高度，要想使他有效，我们需要设置父元素的 height，如果包含块（父元素）的高度没有显式指定或高度为 auto 都会导致失效。
```

### 33. animation、transition、transform、translate 的区别？

> 参考资料：[《CSS3Transition 和 Animation 区别及比较》](https://blog.csdn.net/cddcj/article/details/53582334) [《CSS 动画：animation、transition、transform、translate》](https://juejin.im/post/5b137e6e51882513ac201dfb)

| 属性               | 含义                                       |
| ------------------ | ------------------------------------------ |
| animation（动画）  | 用于设置动画属性                           |
| transition（过渡） | 用于设置元素的样式过度                     |
| transform（变形）  | 用于元素进行旋转、缩放、移动或倾斜         |
| translate（移动）  | translate只是transform的一个属性值，即移动 |

### 34. margin:auto 的填充规则？

```
（1）如果一侧定值，一侧auto，则auto为剩余空间大小。
（2）如果两侧均是auto，则平分剩余空间。
```

### 35. line-height/font-size理解？

<img src='https://img-blog.csdnimg.cn/20190902210836352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEwOTU0OQ==,size_16,color_FFFFFF,t_70' height=300>

### 36. 图片格式 - 7种？

```
（1）第一种是BMP格式，它是无损压缩的，支持索引色和直接色的点阵图。由于它基本上没有进行压缩，因此它的文件体积一般比
较大。
（2）第二种是GIF格式，它是无损压缩的使用索引色的点阵图。由于使用了LZW压缩方法，因此文件的体积很小。并且GIF还
支持动画和透明度。但因为它使用的是索引色，所以它适用于一些对颜色要求不高且需要文件体积小的场景。
（3）第三种是JPEG格式，它是有损压缩的使用直接色的点阵图。由于使用了直接色，色彩较为丰富，一般适用于来存储照片。但
由于使用的是直接色，可能文件的体积相对于GIF格式来说更大。
（4）第四种是PNG-8格式，它是无损压缩的使用索引色的点阵图。它是GIF的一种很好的替代格式，它也支持透明度的调整，并
且文件的体积相对于GIF格式更小。一般来说如果不是需要动画的情况，我们都可以使用PNG-8格式代替GIF格式。
（5）第五种是PNG-24格式，它是无损压缩的使用直接色的点阵图。PNG-24的优点是它使用了压缩算法，所以它的体积比BMP
格式的文件要小得多，但是相对于其他的几种格式，还是要大一些。
（6）第六种格式是svg格式，它是矢量图，它记录的图片的绘制方式，因此对矢量图进行放大和缩小不会产生锯齿和失真。它一般
适合于用来制作一些网站logo或者图标之类的图片。
（7）第七种格式是webp格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用webp格式的最大的优点是，在相
同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减小，
这样会提高用户的体验。这是谷歌开发的一种新的图片格式，目前在兼容性上还不是太好。
```

### 37. absolute定位对overflow:hidden的影响？

```html
<div class="A">
    <div class="B">
        <div class="C">
            <p>AAAAAAAAAAAAAAAAAAAAAAA</p>
            <p>AAAAAAAAAAAAAAAAAAAAAAA</p>
            <p>AAAAAAAAAAAAAAAAAAAAAAA</p>
        </div>
    </div>
</div>
<style>
  .A {
    position: relative;
  }
  .B {
  }
  .C {
    position: absolute;
    top: 0;
    left: 210px;
  }
</style>
```

> （1）在absolute层上若有overflow，即C有overflow，则没有影响，C的内容正常显示；
>
> （2）在absolute层的父级上若有overflow，即B有overflow，则没有影响，C的内容正常显示；
>
> （3）在absolute层的多层父级上若有overflow，即C有overflow，则C的内容只显示相对定位的父元素的区域；

### 38. relative定位的注意点？

```
（1）left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。
（2）当包含块的height为auto时，设置top/bottom的无效，均为0；包含块的width为auto无影响，宽度默认为100%，因此left/right有效。
（3）当同时设置bottom/top时，top有效；当同时设置left/right时，left有效；
```

### 39. 层叠规则？

> z-index大的在上；dom文档流在后的在上。

<img src='img/层叠.png'>

### 40. letter-spacing与word-spacing的区别？

```
（1）letter-spacing可以用来控制 "字符 - 英文字母、汉字以及空格" 之间的间距。
（2）letter-spacing可以用来控制 "空格字符" 之间的间距。
```

### 41. 单行/多行文本溢出省略号的处理？

>参考资料：[《【CSS/JS】如何实现单行／多行文本溢出的省略》](https://zhuanlan.zhihu.com/p/30707916)  [《CSS 多行文本溢出省略显示》](https://juejin.im/entry/587f453e1b69e60058555a5f)

```css
/*单行文本溢出*/
p {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

```css
/*多行文本溢出 - webkit内核浏览器*/
overflow : hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 2; /*限制在一个块元素显示的文本的行数*/
-webkit-box-orient: vertical;

/*多行文本溢出 - 其他浏览器*/
p {
  position: relative;
  line-height: 1.5em;
  height: 3em; /*高度为需要显示的行数×行高*/
  overflow: hidden;
}
p:after {
  content: "...";
  position: absolute;
  bottom: 0;
  right: 0;
  background-color: #fff;
}
```

### 42. 常见的元素隐藏方式？

```
（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，该元素不会在页面中占据位置，也不会响应绑定的监听事件。
（2）使用 visibility:hidden;隐藏元素，元素在页面中仍占据空间，但是不会响应绑定的监听事件。
（3）使用 opacity:0;将元素的透明度设置为0来实现元素的隐藏，元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
（4）通过使用绝对定位将元素移除可视区域内来实现元素的隐藏。
（5）通过 z-index 负值，来使其他元素遮盖住该元素来实现隐藏。
（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
（7）通过 transform:scale(0,0)来将元素缩放为0来实现元素的隐藏，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
```

### 43. CSS布局？

> 参考资料：[《几种常见的 CSS 布局》](https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12)

1. 上下固定中间自适应布局

```
（1）绝对定位。三部分均设置绝对定位，上面和下面设置 top/bottom: 0; 中间设置 top: 100px; bottom: 100px;
（2）flex布局。中间设置 flex-grow: 1;
```

2. 两栏（左固定右自适应）布局

```
（1）浮动布局。左边定宽并左浮动，右边margin-left为左边宽度并且width为auto；
（2）flex布局。左边定宽且flex-shrink和flex-grow均为0，右边flex为auto；
（3）绝对定位。左边定宽且绝对定位，右边margin-left为左边宽度；
（4）绝对定位。左边定宽且绝对定位，右边绝对定位，且left为左边宽度，其他方向为0；
```

3. 三栏（左右固定中间自适应）布局

```
（1）浮动布局。左右浮动，中间设置对应的marhin值，注意中间部分需要放在最后；
（2）flex布局。左右定宽且flex-shrink和flex-grow均为0，中间flex为auto；
（3）绝对定位。左右定宽且绝对定位，中间设置对应的margin值；
（4）双飞翼布局。
（5）圣杯布局。
```

### 44. 宽高自适应的正方形？（自适应比例矩形同理）

> 两个思想：1，基于margin/padding百分比是相对父元素width；2，利用视口（viewport units）单位。

```css
/* 1.利用元素的margin/padding百分比是相对父元素width的性质来实现 */
.square {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: orange;
}

/* 2.利用伪元素的margin-top的值来实现 */
.square {
  width: 30%;
  overflow: hidden;
  background: yellow;
}
.square::after {
  content: "";
  display: block;
  margin-top: 100%;
}

/* 3.利用vw来实现 */
.square {
  width: 10%;
  height: 10vw;
  background: tomato;
}
```

### 45. 双飞翼布局/圣杯布局？

```html
（1）圣杯布局：注意center写在最前面；三个部分都设定为左浮动，然后设置center的宽度为100%；通过设置margin-left为负值让left和right部分回到与center部分同一行，其中left设置margin-left: -100%，rigth设置margin-left: -right宽度；再利用相对定位，定位到两边，并且父容器需要设置设置左右的 padding。
<div class="container">
    <div class="center"></div>
    <div class="left"></div>
    <div class="right"></div>
</div>
<style>
  .container {
    padding-left: 100px;
    padding-right: 200px;
  }

  .left {
    background: red;
    height: 200px;
    width: 200px;

    float: left;
    margin-left: -100%;

    position: relative;
    left: -200px;
  }

  .right {
    background: blue;
    height: 200px;
    width: 200px;

    float: left;
    margin-left: -200px;

    position: relative;
    left: 200px;
  }

  .center {
    background: yellow;
    height: 300px;
    width: 100%;
    float: left;
  }
</style>

（2）双飞翼布局：注意center写在最前面；三个部分都设定为左浮动，然后设置center的宽度为100%；通过设置margin-left为负值让left和right部分回到与center部分同一行，其中left设置margin-left: -100%，rigth设置margin-left: -right宽度；再在center里面嵌套一个div，使其margin为左右的宽度；
<div class="container">
    <div class="center">
        <div class="wrapper">111</div>
    </div>
    <div class="left"></div>
    <div class="right"></div>
</div>
<style>
  .left {
    background: red;
    height: 200px;
    width: 200px;

    float: left;
    margin-left: -100%;
  }

  .right {
    background: blue;
    height: 200px;
    width: 200px;

    float: left;
    margin-left: -200px;
  }

  .center {
    background: yellow;
    height: 300px;
    width: 100%;
    float: left;
  }

  .wrapper{
    margin: 0 200px;
  }
</style>
```

### 46. 百分比总结？

> 参考资料：[详解 CSS 中的百分比的应用](https://juejin.im/entry/592e8a3344d90400645e9a12)

```
（1）width/height —— 相对于父元素的width/height，注意，父元素（定位元素）没有明确的高度定义，则百分比都视为auto；
（2）margin/padding —— 相对于父元素的width（无论什么方向）；
（3）transform: translate —— 自身border-box的尺寸；
（4）定位bottom、left、right、top —— left和right是参照包含块的宽度，bottom和top是参照包含块的高度；
（5）border-radius —— 水平半轴相对于盒模型的宽度，垂直半轴相对于盒模型的高度；
（6）background-position —— 图片移动结果是(父元素-背景图片)*百分比；
（7）line-height —— 自身的font-size；
（8）vertical-align —— 自身的line-height；
```

### 47. CSS优化？

> 参考资料： [《CSS 优化、提高性能的方法有哪些？》](https://www.zhihu.com/question/19886806) [《CSS 优化，提高性能的方法》](https://www.jianshu.com/p/4e673bf24a3b)

```
加载性能：
（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。
（2）css单一样式：当需要下边距和左边距的时候，很多时候选择:margin:top0bottom0;但margin-bottom:bot
tom;margin-left:left;执行的效率更高。
（3）减少使用@import,而建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

选择器性能：
（1）关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到
左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；
（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹
配它们了）。
（3）避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。
（4）尽量少的去对标签进行选择，而是用class。
（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过
三层，更多的使用类来关联每一个标签元素。
（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

渲染性能：
（1）慎重使用高性能属性：浮动、定位。
（2）尽量减少页面重排、重绘。
（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。
（4）属性值为0时，不加单位。
（5）属性值为浮动小数0.**，可以省略小数点之前的0。
（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。
（7）不使用@import前缀，它会影响css的加载速度。
（8）选择器优化嵌套，尽量避免层级过深。
（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清
楚，再使用。
（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。
（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。webfonts通常体积庞大，而且一些浏
览器在下载webfonts时会阻塞页面渲染损伤性能。

可维护性、健壮性：
（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。
（2）样式与内容分离：将css代码定义到外部css中。
```

### 其他注意点

```
（1）border-color 默认颜色就是 color 值。
（2）默认 background 背景图片是相对于 paddingbox 定位的。
（3）font-weight如果为数值则必须是100-900之间的整百数
```



## 3）JS

### 1. JS数据类型？

```
基本数据类型：undefined、null、string、boolean、number、symbol（栈存储）
引用数据类型：Object, Function, Array, Date, RegExp, String, Boolean, Number等（堆存储-栈中仅存地址指针）
```

### 2. null 和 undefined 的区别？

> 参考资料： [《JavaScript 深入理解之 undefined 与 null》](http://cavszhouyou.top/JavaScript深入理解之undefined与null.html)

```
undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null
主要用于赋值给一些可能会返回对象的变量，作为初始化。 null==undefined 为 true；null===undefined 为 false。
```

### 3. 如何安全获取undefined？

```
采用 “void 0” 的方式获取；
```

### 4. 数字不同进制的表示方式？

```
16进制：0X、0x
8进制：0B、0b
2进制：0O、0o、0
```

### 5. 原型、原型链？

<img src='img/原型链.png' />

### 6. 类型转换？

```
总结：两条路径 Object->String->Number 和 Boolean->Number（== 比较的时候也要按路径转移到相同的内容）

（1）其他类型转 String：
	- undefined -> 'undefine', null -> 'null'
	- true -> 'true', false -> 'false'
	- Number -> 直接转换（极小极大值会指数形式）
	- 普通对象 -> '[object object]'（如果对象有自己的 toString() 方法就调用该方法）
（2）其他类型转 Number：
	- Undefined -> NaN, null -> 0
	- true -> 1, false -> 0
	- '' -> 0, 数字类型转数字，非数字类型转 NaN
	- 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。
（3）其他类型转 Boolean：
	- undefined、null、+0、-0、''、false、NaN 为 false，其他为 true
```

### 7. 布尔值的隐式强制转换发生在哪些？

```
（1）if(){}
（2）while(){}
（3）for(;;)
（4）? : 
（5）&&、||、
```

### 8. 如何使字符串转数字？

```
（1）使用 Number()，缺点是不允许出现不合法字符，否则返回NaN
（2）使用 parseInt()/parseInt()，当遇到不合法字符就停止，返回当前结果，注意与 Number() 区别
（3）使用 + 的时候
```

### 9. 生成随机数的方法？

```
随机数：
（1）[0,1) —— Math.random()
（2）[n,m) —— Math.random()*(m-n)+n
（3）[n,m]、(n,m)、(n,m] —— 根据 Math.random()*(m-n)+n 的值 while 循环一下
随机整数：
（4）随机0和1 —— Math.round(Math.random())
（5）随机[0,n)整数 —— Math.floor(Math.random()*n)
（6）随机[1,n]整数 —— Math.floor(Math.random()*n)+1 
（7）随机[n,m]整数 —— Math.floor(Math.random()*(max-min+1))+min
```

### 10. 如何实现数组的随机排序？

```
（1）使用数组 sort 方法，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。
（2）随机从原数组抽取一个元素，加入到新数组
（3）随机交换数组内的元素（类似洗牌算法） - 从 index 0 开始每次都随机选一个和 index 上的元素交换
```

### 11. 对象的继承有哪几种方法？

```js
function Parent(name) {
    this.name = name
    this.getName = function () {
        console.log(`name is ${this.name}`)
    }
}

// 1、原型链继承 —— 子类的原型是父类实例
function Child(age) {
  this.age = age
}
Child.prototype = new Parent('Shen')
const child = new Child(24)

// 2、构造函数继承 —— 使用父类的构造函数来增强子类实例
function Child(name, age) {
    Parent.call(this, name)
    this.age = age
}
const child = new Child('Shen', 24)

// 3、实例继承 —— 为父类实例添加新特性，作为子类实例返回
function Child(name, age) {
    const child = new Parent(name)
    child.age = age
    return child
}
const child = new Child('Shen',24)

// 4、拷贝继承 —— 子类拷贝父类实例的属性和方法
function Child(name, age) {
    const parent = new Parent(name)
    for (let pro in parent) {
        Child.prototype[pro] = parent[pro];
    }
    this.age = age
}
const child = new Child('Shen',24)

// 5、组合继承
function Child(name, age) {
    Parent.call(this, name)
    this.age = age
}
Child.prototype = new Parent()
Child.prototype.constructor = Child
const child = new Child('Shen', 24)

// 6、寄生组合继承
function Child(name, age) {
    Parent.call(this, name)
    this.age = age
}
(function () {
    const Super = function () {}
    Super.prototype = Parent.prototype
    Child.prototype = new Super()
})()
const child = new Child('Shen', 24)

// 7、ES6继承
class Parent {
    constructor(name) {
        this.name = name;
    }
    getName() {
        console.log(`name is ${this.name}`)
    }
}
class Child extends Parent {
    constructor(name, age) {
        super(name);
        this.age = age
    }
}
// 注：ES6的继承super实际执行的是父类.prototype.constructor.call(this)
```

### 12. this的指向？

```
- 默认绑定：全局环境中，this默认绑定到window。
- 隐式绑定：一般被直接对象所包含的函数调用时，this隐式绑定到该直接对象。
- 隐式丢失：call()、apply()、bind()方法。
- new绑定：一般绑定至new生成的新对象，但是如果构造函数返回一个对象，则绑定至该对象。
```

<img src='img/this.png'>

### 13. 改变函数内部 this 指针的指向函数？

|       | 调用方式     | 第一个参数           | 其余参数       |
| ----- | ------------ | -------------------- | -------------- |
| bind  | 返回一个函数 | this指向改变后的对象 | 直接传递       |
| apply | 函数直接调用 | this指向改变后的对象 | 用数组包裹参数 |
| call  | 函数直接调用 | this指向改变后的对象 | 直接传递       |

注意：如果第一个参数为 null 或 undefined，this的指向就是全局变量，在浏览器里就是window对象。

### 14. 事件是什么？

```
事件是用户操作网页时发生的交互动作，事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。
```

### 15. 三种事件模型？

> 参考资料： [《Javascript 事件模型系列（一）事件及事件的三种模型》](https://www.cnblogs.com/lvdabao/p/3265870.html) [《Javascript 事件模型：事件捕获和事件冒泡》](https://blog.csdn.net/wuseyukui/article/details/13771493)

```
（1）DOM0模型：事件发生后不会传播，没有事件流的概念。 <input type=”button” onclick=”func1()” />

（2）IE事件模型：总共两个阶段事件处理阶段和事件冒泡阶段。绑定事件：attachEvent(eventType, handler)；解除事件：detachEvent(eventType, handler)

（3）DOM2模型（重要）：总共三个阶段事件捕获阶段、事件处理阶段和事件冒泡阶段。绑定事件：addEventListener(eventType, handler, useCapture)；解除事件：removeEventListener(eventType, handler, useCapture)
```

### 16. 什么是事件委托？

```js
// 事件委托本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。
// 使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，例如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。

// 关键在于父节点的事件监听函数中需要判断当前事件的的目标元素

var ul = document.querySelector('ul');

ul.addEventListener('click', function (event) {
	// 也可以写成这样 if(e.target && e.target.nodeName.toLowerCase() == "li")
  if (event.target.tagName.toLowerCase() === 'li') {
    // some code
  }
});
```

### 17. 如何阻止冒泡事件和默认事件？

```
（1）e.stopPropagation()，IE 使用 event.cancelBubble = true
（2）e.preventDefault()
```

### 18. 什么是闭包？

```
解释：闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以
访问到当前函数的局部变量。（理解JS的作用域链更好理解）

作用：（1）使我们在函数外部能够访问到函数内部的变量；（2）使已经运行结束的函数上下文中的变量对象继续留在内存中，避免一些计算量巨大的工作重复。
```

### 19. 作用域链与原型链的区别？

```
（1）作用域链是针对变量而言，比如下面就有三个作用域：全局作用域==>函数a作用域==>函数b作用域，作用域链的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找。
    var num = 1;
    function a(){
        var num = 2;
        function b(){
            var num = 3;
            console.log(num); // 3
        }
        b();
    }
    a();
（2）原型链是针对构造函数而言，通过__proto__不断查找。
```

### 20. 判断一个对象是否属于一个类？判断数据的类型？自定义类型判断？

```
（1）typeof 目标 === 'object' - 可以判断基本数据类型(除null为object)，引用对象类型均为object(除function)

（2）目标 instanceof 类名或构造函数名 - 不可以判断基本数据类型，可以判断引用对象类型包括自定义对象

（3）Object.prototype.toString.call(目标).slice(8,-1).toLowerCase() === 'string'  - 可以判断基本数据类型和引用对象类型，不能识别自定义对象

（4）目标.constructor === Object - 可以判断基本数据类型(除null和undefined)和对象数据类型(内置和自定义)
```

### 21. instanceof 的原理？

```js
// target instanceof object
// 原理：判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置
function instanceof(target, object){
  let T = target.__proto__
  let O = object.prototype
  while(true){
    if(T === O){
      return true
    }else if(T === null){
      return false
    }
    T = T.__proto__
  }
}
```

### 22. new操作符干了什么？

```js
const Func=function(){ };  
const func=new Func (); 

// （1）首先创建了一个新的空对象
const obj = new Object();  
// （2）设置原型，将对象的原型设置为函数的 prototype 对象。
obj.__proto__ = Func.prototype;
// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
const result =Func.call(obj); 
// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。
if (typeof(result) === "object" || typeof(result) === "fucntion"){  
  func = result;  
}else{  
  func = obj;;  
}
return func
```

### 23. Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？

```
hasOwnProperty 只检查一个对象是否含有特定的自身属性，和 for in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
```

### 24. [].forEach.call()的理解？

```js
// 开头的数组[]其实没有任何意义，主要用于访问数组的原型，例如这里的forEach方法。
[1,2,3].forEach.call(['a','b'],(item)=>{
  console.log(item)
})
// a
// b
```

### 25. JS延迟加载的方法？

```
（1）放在最后
（2）async/defer —— 区别在于 async 加载完即执行，defer js加载和文档解析同步并且等文档解析完成才按顺序解析JS文件
（3）设置 setTimeout 延迟方法
（4）文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本
```

### 26. AJAX的主要步骤？

```js
// 1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象
// 2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息
// 3.设置响应 HTTP 请求状态变化的函数
// 4.发送 HTTP 请求

// 创建 xhr 对象
const xhr = new XMLHttpRequest()
// 创建 Http 请求
xhr.open("GET", SERVER_URL, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4) {
    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
      console.log(xhr.responseText)
    } else {
      console.log('Error:' + xhr.status)
    }
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);
```

```js
// promise 封装
function ajax() {
  return new Promise((resolve, reject)=>{
    // 上面的代码复制，在请求成功处使用 resolve，在请求失败处使用 reject
  }) 
}
```

### 27. 模块化规范？

```js
// 主要包含4种规范：commonJS、AMD、CMD、ES6，相对 commonJS 和 ES6较为熟悉。

// （1）commonJS. 通过 exports (不建议使用！) 或 module.exports 来导出需要暴露的接口，通过 require 来加载模块。
// 导出
module.exports = {
  func1: function(){}
}
// 引入
const moduleA = require('./moduleA.js')
moduleA.func1()

// （2）ES6. 通过 export default{} 或 expoet 来导出需要暴露的接口，通过 import 来加载模块。注意不同导出方式对应的导入区别。
// 导出-1
export default {}
// 引入-1
import moduleA from './moduleA'
// 导出-2
export function func1(){}
// 引入-2
import {func1} from './moduleA'

```

### 28. documen.write 和 ele.innerHTML区别？

```
（1）document.write("<h1>Main title</h1>") 会代替整个文档内容，重写整个页面。
（2）document.getElementById("main").innerHTML = "Main title" 只是替代指定元素的内容，只会重写页面中的部分内容。
```

### 29. DOM查找的方法？

```
document.querySelector(".myclass");
document.querySelectorAll("div.note");

ele.getElementById();
ele.getElementsByName();
ele.getElementsByTagName();
ele.getElementsByClassName();
```

###  30. innerHTML 与 outerHTML 的区别？

```
（1）innerHTML: 从对象的起始位置到终止位置的全部内容,不包括Html标签。
（2）outerHTML: 除了包含innerHTML的全部内容外, 还包含对象标签本身。

<div id="test"> 
   <span style="color:red">test1</span> test2 
</div>

innerHTML的值是 <span style="color:red">test1</span> test2 
outerHTML的值是 <div id="test"><span style="color:red">test1</span> test2</div>
```

### 31. 类数组对象？

```
一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。

类数组对象转为数组的方法：
（1）Array.from(arrayLike);
（2）[...arrayLike]
（3）Array.prototype.slice.call(arrayLike）
```

### 32. 垃圾回收机制？

> 标记清除 + 引用计数（存在循环引用问题） —— 详见[参考资料](https://segmentfault.com/a/1190000018605776?utm_source=tag-newest)

### 33. 如何判断当前脚本是运行在浏览器还是node环境中？

```js
this === window ? 'browser' : 'node'
```

### 34. 节流与防抖？

> 参考资料： [《轻松理解 JS 函数节流和函数防抖》](https://juejin.im/post/5a35ed25f265da431d3cc1b1) [《JavaScript 事件节流和事件防抖》](https://juejin.im/post/5aa60b0e518825556b6c6d1a) [《JS 的防抖与节流》](https://juejin.im/entry/5b1d2d54f265da6e2545bfa4)

```js
// 节流 - 在 n 秒内只会执行一次，比如说适用于 scroll 监听
function throttle(func, delayTime) {
    let flag;
    return function () {
        let context = this, args = arguments;
        if (!flag) {
            setTimeout(function () {
                func.apply(context, args);
                flag = false
            }, delayTime)
        }
    }
}


// 防抖 - 按最后一次算，在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。
function debounce(func, delayTime) {
    let timeId;
    return function () {
        let context = this, args = arguments;
        timeId && clearTimeout(timeId);
        timeId = setTimeout(function () {
            func.apply(context, args);
        }, delayTime)
    }
}
```

### 35. ==、===、Object.is区别？

```
==值相等（会强制类型转换），===和Object.is值和类型相等，但NaN，+0/-0有区别，Object.is(NaN,NaN)为true，Object.is(+0,-0)为false。
```

### 36. JS事件循环机制？

```
任务队列可以分为宏任务对列和微任务对列，当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。

- MacroTask(宏任务)：script(整体代码), setTimeout, setInterval, requestAnimationFrame, I/O
- MicroTask(微任务)：Promise.then(), await之后的代码, process.nextTick, Object.observe, MutationObserver
注意1，async中如果非异步函数，则认为顺序执行，只有await中为异步，后面的代码才进入微任务队列；
注意2，new Promise 立即执行，then 才分发到微任务
```

### 37. 监听对象属性的改变的方法？

- ES5中使用Object.defineProperty() - 针对单个属性，无法监听属性的添加删除、数组索引和长度变更等

```js
// 第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。
Object.defineProperty(user,'name',{
  set：function(key,value){
  }
})
```

- ES6中使用proxy对象 - 针对整个对象

```js
const user = new Proxy({}, {
  set：function(target,key,value,receiver){
  }
})
```

### 38. 获取元素位置大小的方法？

> 参考资料： [《最全的获取元素宽高及位置的方法》](https://juejin.im/post/5bc9366d5188255c4834e75a) 

```
clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。
clientTop 返回的是上边框的宽度。
clientLeft 返回的左边框的宽度。

offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。
offsetTop 返回的是当前元素相对于其 offsetParent 元素的顶部的距离。
offsetLeft 返回的是当前元素相对于其 offsetParent 元素的左部的距离。

scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。
scrollTop 属性返回的是一个元素的内容垂直滚动的像素数。
scrollLeft 属性返回的是元素滚动条到元素左边的距离。
```

### 39. 谈谈webpack？

```
Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。
（1）Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。
（2）Output 告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。
（3）loader 可以理解为 webpack 的编译器，其使 webpack 可以处理一些非 JS 文件，常用的有 css-loader、style-loader 等。
（4）插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等。
```

### 40. 异步编程的方式？

```
（1）回调函数：其有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。

（2）Promise 对象：其可以将嵌套的回调函数作为链式调用，但是有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。

（3）Generator 函数：当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。

（4）async 函数：async 内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。
```

### 41. JS 动画与 CSS 动画区别？

```
（1）CSS3 动画：在性能上会稍微好一些，且代码相对简单，但是动画控制不够灵活，兼容性不好
（2）JS 动画：控制能力很强，可以单帧的控制、变换，功能强大，对于一些复杂控制的动画，使用 javascript 可能更加合适
```

### 42. 图片的懒加载和预加载？

> 参考资料： [《懒加载和预加载》](https://juejin.im/post/5b0c3b53f265da09253cbed0) [《网页图片加载优化方案》](https://juejin.im/entry/5a73f38cf265da4e99575be3)

```
（1）预加载：的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。

（2）懒加载：懒加载的主要是当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。
```

### 43. Set 和 WeakSet 结构？Map 和 WeakMap 结构？

```
1.Set 类似于数组，但是成员的值都是唯一的，没有重复的值。
2.WeakSet 结构与 Set 类似，也是不重复的值的集合，但是 WeakSet 的成员只能是对象，而不能是其他类型的值。

1.Map 它类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合，但是 WeakMap 只接受对象作为键名（ null 除外。
```

### 44. proxy与reflect对象？

> 参考资料：[proxy](https://es6.ruanyifeng.com/#docs/proxy)  [reflect](https://es6.ruanyifeng.com/#docs/reflect)

### 45. promise对象？手写Promise？

```js
const promise = new Promise(function(resolve, reject) {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

// Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

// 手写promise？
const PENDING = "pending";
const RESOLVED = "resolved";
const REJECTED = "rejected";

function MyPromise(fn) {
  // 保存初始化状态
  var self = this;

  // 初始化状态
  this.state = PENDING;

  // 用于保存 resolve 或者 rejected 传入的值
  this.value = null;

  // 用于保存 resolve 的回调函数
  this.resolvedCallbacks = [];

  // 用于保存 reject 的回调函数
  this.rejectedCallbacks = [];

  // 状态转变为 resolved 方法
  function resolve(value) {
    // 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变
    if (value instanceof MyPromise) {
      return value.then(resolve, reject);
    }

    // 保证代码的执行顺序为本轮事件循环的末尾
    setTimeout(() => {
      // 只有状态为 pending 时才能转变，
      if (self.state === PENDING) {
        // 修改状态
        self.state = RESOLVED;

        // 设置传入的值
        self.value = value;

        // 执行回调函数
        self.resolvedCallbacks.forEach(callback => {
          callback(value);
        });
      }
    }, 0);
  }

  // 状态转变为 rejected 方法
  function reject(value) {
    // 保证代码的执行顺序为本轮事件循环的末尾
    setTimeout(() => {
      // 只有状态为 pending 时才能转变
      if (self.state === PENDING) {
        // 修改状态
        self.state = REJECTED;

        // 设置传入的值
        self.value = value;

        // 执行回调函数
        self.rejectedCallbacks.forEach(callback => {
          callback(value);
        });
      }
    }, 0);
  }

  // 将两个方法传入函数执行
  try {
    fn(resolve, reject);
  } catch (e) {
    // 遇到错误时，捕获错误，执行 reject 函数
    reject(e);
  }
}

MyPromise.prototype.then = function(onResolved, onRejected) {
  // 首先判断两个参数是否为函数类型，因为这两个参数是可选参数
  onResolved =
    typeof onResolved === "function"
      ? onResolved
      : function(value) {
          return value;
        };

  onRejected =
    typeof onRejected === "function"
      ? onRejected
      : function(error) {
          throw error;
        };

  // 如果是等待状态，则将函数加入对应列表中
  if (this.state === PENDING) {
    this.resolvedCallbacks.push(onResolved);
    this.rejectedCallbacks.push(onRejected);
  }

  // 如果状态已经凝固，则直接执行对应状态的函数

  if (this.state === RESOLVED) {
    onResolved(this.value);
  }

  if (this.state === REJECTED) {
    onRejected(this.value);
  }
};
```

### 46. 使用闭包实现每隔一秒打印 1,2,3,4

```js
// 闭包
for (let i = 0; i < 4; i++) {
    (function(i) {
        setTimeout(function() {
            console.log(i);
        }, i * 1000);
    })(i)
}

// 注意本身 let 块级作用域也能实现
for (let i = 0; i < 4; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```

### 47. 手写一个JSONP-跨域？

```js
// 1、创建script节点
const script = document.createElement('script')
// 2、设置src以及如果需要返回数据则设置回调函数
script.src = 'http://localhost:8080/?callback=displayData&&user=envision';
// 3、将回调函数添加至document
document.body.append(script);
// 4、设置回调函数
function displayData(data) {
   alert(data);
}
```

### 48. 静态方法、公有方法、私有方法的区别？

```js
function User(name) {
	var name = name + 'hello'; // 私有属性
	this.name = name; // 公有属性
	function getName() { // 私有方法
		return name;
	}
}
User.prototype.getName = function() { // 公有方法
	return this.name;
}
User.name = 'Wscats'; // 静态属性
User.getName = function() { // 静态方法
	return this.name;
}
var man = new User('sherwin'); //实例化

// 实例化对象 man 才能调用公有属性和公有方法
// 实例化对象 man 不能调用私有方法和静态方法
// 静态方法和静态属性直接通过对象 User 调用
// 私有属性和私有方法外部是不可以访问的
```

### 49. 函数声明与函数表达式声明的区别？

```js
// var存在变量提升，将变量getName提升，但后面的函数还没有赋值，function也存在提升，但是是整体提升
getName() // man
var getName = function() {
    console.log('woman')
}
getName() // woman
function getName() {
    console.log('man')
}
getName() //woman
```

### 50. 一个列表，假设有 100000 个数据，这个该怎么办？

```
（1）将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。

（2）使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。

（3）使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。
```

### 51. 设计模式？

> 参考资料： [《JavaScript 设计模式》](https://juejin.im/post/59df4f74f265da430f311909#heading-3) [《JavaScript 中常见设计模式整理》](https://juejin.im/post/5afe6430518825428630bc4d)

### 52. 使用setTimeout模拟setInterval？

```js
function mySetInterval(fn, time) {
    function myFunc(){
        fn()
        setTimeout(myFunc,time)
    }
    setTimeout(myFunc,time)
}

// 需要有暂停功能
function mySetInterval(fn, time) {
    let timer = {
        flag: true
    }

    function myFunc() {
        if (timer.flag) {
            fn()
            setTimeout(myFunc, time)
        }
    }

    setTimeout(myFunc, time)
    return timer
}

let timer = mySetInterval(() => {
    console.log('hello')
}, 1000)

setTimeout(()=>{
    timer.flag = false
},4000)
```

### 53. 数组/String相关方法？

``` 
数组：
（1）改变数组：pop() push() unshift() shift() splice() reverse() sort()
（2）遍历数组：forEach() filter() reduce() map() every() some()
（3）查询数组：find, findIndex, includes, indexOf, lastIndexOf
（3）其他方法：slice() concat() fil() join() 
String：
（1）slice, substring, substr, indexOf, replace, split, includes, search, repeat, trim, charCodeAt

公共的方法：slice,indexOf, includes, concat
```

### 54. 深浅拷贝的实现？

```js
// 浅拷贝的实现;

function shallowCopy(object) {
  // 只拷贝对象
  if (!object || typeof object !== "object") return;

  // 根据 object 的类型判断是新建一个数组还是对象
  let newObject = Array.isArray(object) ? [] : {};

  // 遍历 object，并且判断是 object 的属性才拷贝
  for (let key in object) {
    if (object.hasOwnProperty(key)) {
      newObject[key] = object[key];
    }
  }

  return newObject;
}

// 深拷贝的实现;

function deepCopy(object) {
  if (!object || typeof object !== "object") return;

  let newObject = Array.isArray(object) ? [] : {};

  for (let key in object) {
    if (object.hasOwnProperty(key)) {
      newObject[key] =
        typeof object[key] === "object" ? deepCopy(object[key]) : object[key];
    }
  }

  return newObject;
}
```

### 55. call、apply、bind手写？

```
call 函数的实现步骤：
1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。
3.处理传入的参数，截取第一个参数后的所有参数。
4.将函数作为上下文对象的一个属性。
5.使用上下文对象来调用这个方法，并保存返回结果。
6.删除刚才新增的属性。
7.返回结果。

apply 函数的实现步骤：
1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。
3.将函数作为上下文对象的一个属性。
4.判断参数值是否传入
4.使用上下文对象来调用这个方法，并保存返回结果。
5.删除刚才新增的属性
6.返回结果

bind 函数的实现步骤：
1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
2.保存当前函数的引用，获取其余传入参数值。
3.创建一个函数返回
4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。
```

```js
// call函数实现
Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }

  // 获取参数
  let args = [...arguments].slice(1),
    result = null;

  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;

  // 将调用函数设为对象的方法
  context.fn = this;

  // 调用函数
  result = context.fn(...args);

  // 将属性删除
  delete context.fn;

  return result;
};

// apply 函数实现
Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }

  let result = null;

  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;

  // 将函数设为对象的方法
  context.fn = this;

  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }

  // 将属性删除
  delete context.fn;

  return result;
};

// bind 函数实现
Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }

  // 获取参数
  var args = [...arguments].slice(1),
    fn = this;

  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
```

### 56. 函数柯里化

> 参考资料： [《JavaScript 专题之函数柯里化》](https://github.com/mqyqingfeng/Blog/issues/42)  [js如何用一句代码实现函数的柯里化](https://www.jianshu.com/p/c87242cd2f6c)

```js
// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。
// es6 实现
const curry = ( fn, arr = []) => (...args) => ( a => a.length === fn.length? fn(...a) : curry(fn, a))([...arr, ...args]) 
```

### 其他注意点

```
（1）NaN 表示 not a number，但是要注意 typeof NaN 为 number，并且 NaN 与自身不相等；
（2）new Array (x) 只有一个参数的时候表示数组长度，多个参数就是该数组的值
（3）let 和 const 不存在声明提升，存在暂时性死区，如果在变量声明前使用，会报错
```



## 4）浏览器/计算机网络

**注意！主要内容详见[计算机网络面试总结](https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/计算机网络/计算机网络.md)**

### 1. 浏览器缓存机制？

> 参考资料： [《浅谈浏览器缓存》](https://segmentfault.com/a/1190000012573337) [《浏览器缓存技术介绍》](https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3) [《请求头中的 Cache-Control》](https://www.web-tinker.com/article/21221.html) [《Cache-Control 字段值详解》](https://juejin.im/post/5c2d6c9ae51d450cf4195a08)

```
详见2020春招面试总结
```

### 2. 浏览器同源政策？

```
解释：指的是域的协议、域名、端口都必须一致。

限制：
（1）当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。
（2）当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。
（3）当前域下 ajax 无法发送跨域请求。
```

### 3. 浏览器跨域方法？

> 参考资料： [《前端常见跨域解决方案（全）》](https://segmentfault.com/a/1190000011145364) [《浏览器同源政策及其规避方法》](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) [《跨域，你需要知道的全在这里》](https://juejin.im/entry/59feae9df265da43094488f6) 

```
- CORS（Access-Control-Allow-Origin）
- JSONP
- postMessage + onmessage
- Nginx
- nodejs中间件
- WebSocket
- document.domain + iframe跨域
- location.hash + iframe跨域（onhashchange）
- window.name + iframe跨域
```

### 4. cookie的属性？

<img src='img/cookie.png'>

```
- Name: 名字
- Value: 值
- Domain: 可以访问cookie的域名
- path: 可以访问此cookie的页面路径
- HttpOnly: 若设为true则无法通过js读取cookie的内容，防止了XSS攻击
- Expires/Max-age: 超时时间
- Size: 大小
```

### 5. 前端安全有哪些注意点？

```
（1）CSRF 跨站请求伪造
（2）XSS 跨站脚本攻击
（3）SQL注入
（4）点击劫持
（5）中间人攻击
```

### 6. 什么是 XSS 攻击？如何防范 XSS 攻击？

> 参考资料： [《前端安全系列（一）：如何防止 XSS 攻击？》](https://juejin.im/post/5bad9140e51d450e935c6d64)

```
Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，恶意代码未经过滤，与网站正常的代码混在一起,浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

防御方法：
（1）输入过滤
（2）转义 HTML - 建议使用成熟的转义库，而不是自己写
（3）HTTP-only Cookie - 禁止 JavaScript 读取某些敏感 Cookie
（4）验证码 - 防止脚本冒充用户提交危险操作
```

###  7. 什么是 CSRF 攻击？如何防范 CSRF 攻击？

> 参考资料： [《前端安全系列之二：如何防止 CSRF 攻击？》](https://juejin.im/post/5bc009996fb9a05d0a055192)

```
CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

典型流程：
1、受害者登录a.com，并保留了登录凭证（Cookie）。
2、攻击者引诱受害者访问了b.com。
3、b.com 向 a.com 发送了一个请求：a.com/act=xx
4、a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
5、a.com以受害者的名义执行了act=xx。
6、攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。

防御方法：
（1）使用 Origin Header 确定来源域名 - 请求的Header中会携带Origin字段，字段内包含请求的域名（不包含path及query）
（2）使用 Referer Header 确定来源域名 - 在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址
（3）CSRF Token
（4）Samesite Cookie 属性
```

### 8. 什么是点击劫持？如何防范点击劫持？

> 参考资料： [《web 安全之--点击劫持攻击与防御技术简介》](https://www.jianshu.com/p/251704d8ff18)

```
点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。
```

### 9. 什么是SQL 注入攻击？如何防范 SQL 注入攻击？

> 参考资料： [《Web 安全漏洞之 SQL 注入》](https://juejin.im/post/5bd5b820e51d456f72531fa8) [《如何防范常见的 Web 攻击》](http://blog.720ui.com/2016/security_web/#SQL注入攻击) 

```
SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构
造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。
```

### 10. URI、URL 和 URN 的区别？

```
解释：
（1）URI（Uniform Resource Identifier）统一资源标识符
（2）URL（Uniform Resource Location）统一资源定位符
（3）URN（Universal Resource Name）统一资源名称

URI 用唯一的标识来确定一个资源，它是一种抽象的定义，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。URL 指的是统一资源定位符，URN 指的是统一资源名称，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。
```

### 11. 开发中常用的几种 Content-Type ？

```
（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。

（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

（3）application/json：告诉服务器消息主体是序列化后的 JSON 字符串。

（4）text/xml：该种方式主要用来提交 XML 格式的数据。
```

### 12. 如何判断一个对象为空？

```js
function isNull(obj) {
    // 方法1
    return Object.keys(obj).length === 0
    // 方法2
    obj.forEach(() => {
        return false
    });
    return true
    // 方法3
    return JSON.stringify(obj) !== '{}';
}
```

### 13. 什么是 Cookie 隔离（请求资源的时候不要让它带 cookie 怎么做）？

```
网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开，静态资源放CDN。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。
```



## 5）前端框架

### 1. vue 双向数据绑定原理？

```
详见2020春招面试总结
```

### 2. vue生命周期以及钩子函数？

```
Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。

（1）beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。
（2）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。
（3）beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。
（4）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。
（5）beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。
（6）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。
（7）beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。
（8）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。
（9）当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。
```

### 3. Vue 组件间的参数传递方式？

> 参考资料： [《VUE 组件之间数据传递全集》](https://juejin.im/entry/5ba215ac5188255c6d0d8345)

```
（1）父子组件间通信

第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事
件来向父组件发送数据。
第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组
件，这样也可以实现通信。
第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件
中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。

（2）兄弟组件间通信

第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实
例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。
第二种是通过 $parent.$refs 来获取到兄弟组件，也可以进行通信。

（3）任意组件之间

使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
```

### 4. computed 和 watch 的差异？

```
（1）computed 只有当依赖发生改变，第一次访问 computed 属性，才会计算新的值，适用于一个数据被多个数据影响
（2）watch 是有当该值发生改变时才会回调，适用于一个数据影响多个数据
```

### 5. $route 和 $router 的区别？

```
$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。
$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。
```



## 6）算法

详见[算法专题](https://github.com/MrEnvision/LeetCode_JS)



## 7）其他

### 1. 前端单元测试？

> TDD（测试驱动开发）&BDD（行为驱动开发），参考资料： [《浅谈前端单元测试》](https://juejin.im/post/5b2da89cf265da597f1c7cab)



------

如果发现本项目有错误，欢迎提交 issues 指正。